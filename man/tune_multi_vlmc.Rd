% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vlmc_tune_multi.R
\name{tune_multi_vlmc}
\alias{tune_multi_vlmc}
\title{Fit an optimal Variable Length Markov Chain (VLMC) on a collection of discrete time series}
\usage{
tune_multi_vlmc(
  xs,
  criterion = c("BIC", "AIC"),
  initial = c("truncated", "specific", "extended"),
  alpha_init = NULL,
  cutoff_init = NULL,
  min_size = 2L,
  max_depth = 10L,
  verbose = 0,
  save = c("best", "initial", "all"),
  weights = NULL
)
}
\arguments{
\item{xs}{a list of discrete times series}

\item{criterion}{criterion used to select the best model. Either \code{"BIC"}
(default) or \code{"AIC"} (see details).}

\item{initial}{specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are
integrated in the likelihood. Default to \code{"truncated"}. See
\code{\link[=loglikelihood]{loglikelihood()}} for details.}

\item{alpha_init}{if non \code{NULL} used as the initial cut off parameter (in
quantile scale) to build the initial VLMC}

\item{cutoff_init}{if non \code{NULL} used as the initial cut off parameter to
build the initial VLMC. Takes precedence over \code{alpha_init} if specified.}

\item{min_size}{integer >= 1 (default: 2). Minimum number of observations for
a context in the growing phase of the initial context tree.}

\item{max_depth}{integer >= 1 (default: 100). Longest context considered in
growing phase of the initial context tree (see details).}

\item{verbose}{integer >= 0 (default: 0). Verbosity level of the pruning
process.}

\item{save}{specify which BIC models are saved during the pruning process.
The default value \code{"best"} asks the function to keep only the best model
according to the \code{criterion}. When \code{save="initial"} the function keeps \emph{in
addition} the initial (complex) model which is then pruned during the
selection process. When \code{save="all"}, the function returns all the models
considered during the selection process.}

\item{weights}{optional weights for the time series, see details}
}
\value{
a list with the following components:
\itemize{
\item \code{best_model}: the optimal VLMC
\item \code{criterion}: the criterion used to select the optimal VLMC
\item \code{initial}: the likelihood function used to select the optimal VLMC
\item \code{results}: a data frame with details about the pruning process
\item \code{saved_models}: a list of intermediate VLMCs if \code{save="initial"} or
\code{save="all"}. It contains an \code{initial} component with the large VLMC
obtained first and an \code{all} component with a list of all the \emph{other} VLMC
obtained by pruning the initial one.
}
}
\description{
This function fits a Variable Length Markov Chain (VLMC) to a collection of
discrete time series by optimizing an information criterion (BIC or AIC).
}
\details{
This function is very similar to \code{\link[=tune_vlmc]{tune_vlmc()}} as it automates the process of
selecting the complexity of a VLMC with an information criterion. The only
difference with \code{\link[=tune_vlmc]{tune_vlmc()}} is that the VLMC is estimated on a collection of
discrete time series rather than on a single one. The internal estimation is
therefore based on \code{\link[=multi_vlmc]{multi_vlmc()}} rather than \code{\link[=vlmc]{vlmc()}}: in particular
the time series can be weighted using the \code{weights} parameter.
}
\section{Weights}{


If given, the \code{weights} parameter must be a vector of non negative values of the
same length as \code{xs}. Each time series is then weighted using the corresponding
weight. Weights are interpreted as fractional number of occurrences when
\code{min_size} is checked. A context is kept in the context tree if the sum of
the weights of the series in which it appears is larger than the \code{min_size}
threshold. Conditional probabilities associated to contexts are computed
from the weighted occurrences.
}

\examples{
pc <- powerconsumption[powerconsumption$week \%in\% 5:7, ]
powerlevels <- quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))
dts <- lapply(
  5:7,
  function(x) {
    cut(pc$active_power[pc$week == x],
      breaks = c(0, powerlevels)
    )
  }
)
best_vlmc <- tune_multi_vlmc(dts, alpha_init = 0.001)
}
\seealso{
\code{\link[=multi_vlmc]{multi_vlmc()}}
}
