% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vlmc_multi.R
\name{multi_vlmc}
\alias{multi_vlmc}
\title{Fit a Variable Length Markov Chain (VLMC) to a collection of time series}
\usage{
multi_vlmc(
  xs,
  alpha = 0.05,
  cutoff = NULL,
  min_size = 2L,
  max_depth = 100L,
  prune = TRUE,
  keep_match = FALSE,
  weights = NULL
)
}
\arguments{
\item{xs}{list of discrete times series}

\item{alpha}{number in (0,1] (default: 0.05) cut off value in quantile scale
in the pruning phase.}

\item{cutoff}{non negative number: cut off value in native (likelihood ratio)
scale in the pruning phase. Defaults to the value obtained from \code{alpha}.
Takes precedence over \code{alpha} is specified.}

\item{min_size}{integer >= 1 (default: 2). Minimum number of observations for
a context in the growing phase of the context tree.}

\item{max_depth}{integer >= 1 (default: 100). Longest context considered in
growing phase of the context tree.}

\item{prune}{logical: specify whether the context tree should be pruned
(default behaviour).}

\item{keep_match}{logical: specify whether to keep the context matches
(default to FALSE)}

\item{weights}{optional weights for the time series, see details.}
}
\value{
a fitted vlmc model (of class \code{multi_vlmc})
}
\description{
This function fits a  Variable Length Markov Chain (VLMC) to a collection of
discrete time series.
}
\section{Weights}{


If given, the \code{weights} parameter must be a vector of non negative values of the
same length as \code{xs}. Each time series is then weighted using the corresponding
weight. Weights are interpreted as fractional number of occurrences when
\code{min_size} is checked. A context is kept in the context tree if the sum of
the weights of the series in which it appears is larger than the \code{min_size}
threshold. Conditional probabilities associated to contexts are computed
from the weighted occurrences.
}

\examples{
pc <- powerconsumption[powerconsumption$week \%in\% 5:8, ]
powerlevels <- quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))
dts <- tapply(pc$active_power, pc$week, \(x) cut(x, breaks = c(0, powerlevels)))
model <- multi_vlmc(dts, max_depth = 3)
draw(model)
depth(model)
}
\seealso{
\code{\link[=multi_ctx_tree]{multi_ctx_tree()}}, \code{\link[=vlmc]{vlmc()}}
}
