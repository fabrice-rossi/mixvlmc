% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vlmc_simulate_cpp.R
\name{simulate.vlmc_cpp}
\alias{simulate.vlmc_cpp}
\title{Simulate a discrete time series for a vlmc}
\usage{
\method{simulate}{vlmc_cpp}(
  object,
  nsim = 1,
  seed = NULL,
  init = NULL,
  sample = c("fast", "slow", "R"),
  ...
)
}
\arguments{
\item{object}{a fitted vlmc object.}

\item{nsim}{length of the simulated time series (defaults to 1).}

\item{seed}{an optional random seed.}

\item{init}{an optional initial sequence for the time series}

\item{sample}{specifies which implementation of \code{\link[base:sample]{base::sample()}} to use.
See the dedicated section.}

\item{...}{additional arguments.}
}
\value{
a simulated discrete time series of the same type as the one used to build the vlmc.
}
\description{
This function simulates a time series from the distribution estimated by the
given vlmc object.
}
\details{
The time series can be initiated by a fixed sequence specified via the \code{init}
parameter.
}
\section{sampling method}{


The R backend for \code{\link[=vlmc]{vlmc()}} uses \code{\link[base:sample]{base::sample()}} to generate samples for each
context. Internally, this function sorts the probabilities of each state in
decreasing probability order (among other things), which is not needed in our
case. The C++ backend can be used with three different implementations:
\itemize{
\item \code{sample="fast"} uses a dedicated C++ implementation adapted to the data structures
used internally. In general, the simulated time series obtained with this
implementation will be different from the one generated with the R backend,
even using the same seed.
\item \code{sample="slow"} uses another C++ implementation that mimics \code{\link[base:sample]{base::sample()}} in
order to maximize the chance to provide identical simulation results regardless
of the backend (when using the same random seed). This process is not perfect
as we use the std::lib sort algorithm which is not guaranteed to give identical
results as the ones of R internal 'revsort'.
\item \code{sample="R"} uses direct calls to \code{\link[base:sample]{base::sample()}}. Results are guaranteed
to be identical between the two backends, but at the price of higher running
time.
}
}

\examples{
pc <- powerconsumption[powerconsumption$week == 5, ]
dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model <- vlmc(dts, min_size = 5)
new_dts <- simulate(model, 500, seed = 0)
new_dts_2 <- simulate(model, 500, seed = 0, init = dts[1:5])
}
