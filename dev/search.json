[{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/context-trees.html","id":"definition","dir":"Articles","previous_headings":"Contexts","what":"Definition","title":"Context trees","text":"consider time series \\(x=(x_i)_{\\geq 1}\\) values finite set \\(S\\), state space. context \\(c\\) finite sequence elements \\(S\\), \\(c=(c_1, \\ldots, c_k)\\) observed \\(x\\). \\(c\\) observed \\(x\\) \\(t\\) \\[ x_{t-1}=c_1, x_{t-2}=c_2, \\ldots, x_{t-k}=c_k. \\] Notice \\(c\\) written reverse order, sense \\(c_1\\) recent value \\(x\\) \\(c_k\\) oldest one. Thus sub-sequence observed \\(x\\) \\((c_k, c_{k-1}, \\ldots, c_1)\\). follow Bühlmann Wyner convention. instance, \\(S=\\{0, 1\\}\\) \\(x=(0, 0, 0, 1, 1, 1)\\) \\((0, 0)\\) context \\(x\\) \\(t=3\\) \\(t=4\\); \\((0, 1, 0)\\) context \\(x\\).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/context-trees.html","id":"context-trees","dir":"Articles","previous_headings":"Contexts","what":"Context trees","title":"Context trees","text":"contexts time series can represented tree. root tree stands empty context. children root represent contexts length 1. general, node represents context \\(c=(c_1, \\ldots, c_k)\\), contexts form \\(c'=(c_1, \\ldots, c_k, c_{k+1})\\) represented children node. Let us consider \\(x=(0, 0, 0, 1, 1, 1)\\) contexts appear least twice \\(x\\) (.e. observed least two different values \\(t\\)). ASCII art representation corresponding context tree : tree represents 2 size one contexts (\\((0)\\) \\((1)\\)), direct children root (shown star *). represents addition 1 size 2 contexts, \\((0, 0)\\). Notice instance, \\((0, 1)\\) context tree node context \\((0)\\) one child labelled \\(0\\).","code":"* +-- 0 |   '-- 0 '-- 1"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/context-trees.html","id":"extracting-contexts-from-a-time-series-in-mixvlmc","dir":"Articles","previous_headings":"","what":"Extracting contexts from a time series in mixvlmc","title":"Context trees","text":"Mixvlmc can used compute contexts time series using ctx_tree function/constructor follows: result ctx_tree() ctx_tree object. can drawn using ascii art default extraction done min_size=2 max_depth=10 means contexts included appear least twice time series; maximum length context 10 (term depth used reference tree representation). Notice number potential contexts grows exponentially length time series therefore advisable keep max_depth reasonable value. Let us consider simple example. default parameters, end already 77 contexts. Setting min_size=1 gives unreasonable number contexts: raise depth limit, number contexts keeps increasing: Contexts can extracted context tree using contexts function follows: general, raw list contexts useful contexts can parametrized give additional information contexts. simple case ctx_tree, setting frequency parameter \"total\" \"detailed\" gives access distribution \\(x_t\\) \\(t\\) context appears. frequency = \"total\", obtain data frame column freq contains number occurrences context. frequency = \"detailed\", obtain addition column value state space \\(S\\) contains distribution \\(x_t\\) occurrences context. instance table , context \\((0, 0)\\) appears twice \\(x\\) followed \\(0\\) \\(1\\).","code":"x <- c(0, 0, 0, 1, 1, 1) library(mixvlmc) x_ctx <- ctx_tree(x) x_ctx #> Context tree on 0, 1  #>  Number of contexts: 3  #>  Maximum context length: 2 draw(x_ctx) #> * #> +-- 0 #> |   '-- 0 #> '-- 1 set.seed(0) y <- sample(c(\"a\", \"b\", \"c\"), 100, replace = TRUE) y_ctx_def <- ctx_tree(y) y_ctx_def #> Context tree on a, b, c  #>  Number of contexts: 77  #>  Maximum context length: 6 y_ctx_min_1 <- ctx_tree(y, min_size = 1) y_ctx_min_1 #> Context tree on a, b, c  #>  Number of contexts: 4607  #>  Maximum context length: 99 y_ctx_min_1_d_15 <- ctx_tree(y, min_size = 1, max_depth = 15) y_ctx_min_1_d_15 #> Context tree on a, b, c  #>  Number of contexts: 1037  #>  Maximum context length: 15 contexts(x_ctx) #> [[1]] #> [1] 0 0 #>  #> [[2]] #> [1] 0 #>  #> [[3]] #> [1] 1 contexts(x_ctx, frequency = \"total\") #>   context freq #> 1    0, 0    2 #> 2       0    3 #> 3       1    2 contexts(x_ctx, frequency = \"detailed\") #>   context freq 0 1 #> 1    0, 0    2 1 1 #> 2       0    3 2 1 #> 3       1    2 0 2"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"limitations-of-variable-length-markov-chains","dir":"Articles","previous_headings":"","what":"Limitations of Variable Length Markov Chains","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"Variable Length Markov Chains (VLMC) useful capture complex structures discrete time series can mix short memory long memory contextual way, leading sparse models. However, capture influence exogenous variables behaviour time series. consequence, VLMC adjusted sequences influenced covariates fail capture interesting patterns.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"a-typical-example","dir":"Articles","previous_headings":"Limitations of Variable Length Markov Chains","what":"A typical example","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"Let us focus electrical usage data set used package introduction, using following two weeks data:  build discrete time series using following thresholds: low active power night (typically 0.4 kW); standard use 0.4 2 kW; peak use 2 kW. Adjusting VLMC sequence gives following model (using BIC model selection): Considering apparent regularity time series, one may wonder whether model really capturing dynamics power electricity consumption. particular longest memory 3 time steps, .e., 30 minutes, may seem bit short compared somewhat long periods stability.","code":"pc_week_15_16 <- powerconsumption[powerconsumption$week %in% c(15, 16), ] elec <- pc_week_15_16$active_power ggplot(pc_week_15_16, aes(x = date_time, y = active_power)) +   geom_line() +   xlab(\"Date\") +   ylab(\"Activer power (kW)\") elec_dts <- cut(elec, breaks = c(0, 0.4, 2, 8), labels = c(\"low\", \"typical\", \"high\")) elec_vlmc_tune <- tune_vlmc(elec_dts) best_elec_vlmc <- as_vlmc(elec_vlmc_tune) draw(best_elec_vlmc) #> * (0.3269, 0.4841, 0.189) #> +-- low (0.8088, 0.1821, 0.009105) #> '-- typical (0.1292, 0.8041, 0.06667) #> |   +-- low (0.3667, 0.5833, 0.05) #> |   '-- typical (0.1022, 0.8365, 0.0613) #> |       '-- low (0.4058, 0.5507, 0.04348) #> '-- high (0, 0.1864, 0.8136)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"theoretical-aspects","dir":"Articles","previous_headings":"","what":"Theoretical aspects","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"VLMC covariates introduced Variable length Markov chain exogenous covariates. core idea enable conditional probabilities next state given context depend exogenous covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"variable-memory","dir":"Articles","previous_headings":"Theoretical aspects","what":"Variable memory","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"COVLMC models pair sequences. main sequence denoted \\(\\mathbf{X}=X_1, X_2, \\ldots, X_n, \\ldots\\). random variables take values finite state space \\(S\\) exactly standard VLMC. addition another sequence random variables \\(\\mathbf{Y}=Y_1, Y_2, \\ldots, Y_n, \\ldots\\) take values \\(\\mathbb{R}^p\\). latter assumption \\(Y_l\\\\mathbb{R}^p\\) can relaxed general spaces. COVLMC puts restriction conditional probabilities \\(X_n\\) given past sequences. simplify presentation, denote \\(X^k_l\\) sequence random variables \\[ X^k_m=(X_k, X_{k-1}, \\ldots, X_m), \\] use similar notations values taken variables \\(x^k_m\\), well \\(Y^k_m\\) \\(y^k_m\\). use traditional reverser ordering \\(X_k\\) recent variable \\(X_m\\) oldest. pair sequences \\(\\mathbf{X}\\) \\(\\mathbf{Y}\\) COVLMC maximal order \\(l_{\\max}\\) function \\(l\\) \\(S^{l_{\\max}}\\) \\(\\{0,\\ldots,l_{\\max}\\}\\) \\(n>l_{\\max}\\) \\[ \\begin{multline} \\mathbb{P}(X_n=x_n\\mid X^{n-1}_1=x^{n-1}_1, Y^{n-1}_1=y^{n-1}_1)=\\\\ \\mathbb{P}\\left(X_n=x_n\\mid X^{n-1}_{n-l\\left(x^{n-1}_{n-l_{\\max}}\\right)}=x^{n-1}_{n-l\\left(x^{n-1}_{n-l_{\\max}}\\right)}, Y^{n-1}_{n-l\\left(x^{n-1}_{n-l_{\\max}}\\right)}=y^{n-1}_{n-l\\left(x^{n-1}_{n-l_{\\max}}\\right)}\\right). \\end{multline} \\] VLMC, \\(\\mathbf{X}\\) process finite variable memory, memory applies \\(\\mathbf{X}\\) \\(\\mathbf{Y}\\). Notice memory order depends \\(\\mathbf{X}\\) assumptions made temporal behaviour \\(\\mathbf{Y}\\). Thus COVLMC \\(\\mathbf{X}\\) \\(\\mathbf{Y}\\) VLMC pair \\((\\mathbf{X}, \\mathbf{Y})\\) (can make sense \\(\\mathbf{Y}\\) discrete). VLMC, memory length function generates context function \\(c\\) keeps past part needed obtain conditional distribution: \\(c\\) function \\(S^{l_{\\max}}\\) \\(\\bigcup_{k=0}^{l_{\\max}}S^k\\) given \\[ c(x^{n-1}_{n-l_{\\max}})=x^{n-1}_{n-l\\left(x^{n-1}_{n-l_{\\max}}\\right)} \\] image \\(c\\) \\(S^{l_{\\max}}\\) set contexts COVLMC entirely specified \\(l\\) one conditional distribution unique context. notations somewhat opaque first, can illustrate definition simple example. consider binary sequence (values \\(S=\\{0, 1\\}\\)) single numerical covariate \\(Y_t\\\\mathbb{R}\\). theoretical example vignette(\"variable-length-markov-chains\") assume \\(l_{\\max}=3\\) \\(l\\) given \\[ \\begin{align*} l(0, , b)&=1&\\forall , \\forall b,\\\\ l(1, 1, c)&=2&\\forall c,\\\\ l(1, 0, 0)&=3,&\\\\ l(1, 0, 1)&=3.&\\\\ \\end{align*} \\] practice COVLMC therefore fully described specifying following probabilities: \\[ \\begin{align*} \\mathbb{P}(X_t=1\\mid& X_{t-1}=0, Y_{t-1}=y_{t-1})\\\\ \\mathbb{P}(X_t=1\\mid& X_{t-1}=1, X_{t-2}=1, Y_{t-1}=y_{t-1}, Y_{t-2}=y_{t-2})\\\\ \\mathbb{P}(X_t=1\\mid& X_{t-1}=1, X_{t-2}=0, X_{t-3}=0, Y_{t-1}=y_{t-1}, Y_{t-2}=y_{t-2}, Y_{t-3}=y_{t-3})\\\\ \\mathbb{P}(X_t=1\\mid& X_{t-1}=1, X_{t-2}=0, X_{t-3}=1, Y_{t-1}=y_{t-1}, Y_{t-2}=y_{t-2}, Y_{t-3}=y_{t-3}) \\end{align*} \\]","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"conditional-distributions","dir":"Articles","previous_headings":"Theoretical aspects","what":"Conditional distributions","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"main difficulty induced COVLMC compared VLMC specification conditional distributions. Indeed conditional distributions depend \\(\\mathbf{Y}\\) simply given table. instance, example , need specify, among others, \\(\\mathbb{P}(X_t=1\\mid X_{t-1}=0, Y_{t_1}=y_{t-1})\\), values \\(y_{t-1}\\\\mathbb{R}\\) (\\(\\mathbb{R}^p\\) general case). natural choice particular example use logistic model, .e. assume \\[ \\mathbb{P}(X_t=1\\mid X_{t-1}=0, Y_{t_1}=y_{t-1})=g(\\alpha^0+y_{t-1}\\beta_1^0), \\] \\(g(t)=\\frac{1}{1+\\exp(-t)}\\) logistic function. superscript \\(\\alpha^0\\) \\(\\beta^0_1\\) refer context, \\(0\\), subscript \\(\\beta^0_1\\) refers time delay (\\(1\\)). extension, example \\[ \\begin{multline*} \\mathbb{P}(X_t=1\\mid X_{t-1}=1, X_{t-2}=1, Y_{t_1}=y_{t-1}, Y_{t_2}=y_{t-2})=\\\\ g\\left(\\alpha^{1,1}+y_{t-1}\\beta^{1,1}_1+y_{t-2}\\beta^{1,1}_2\\right). \\end{multline*} \\] generally, probability distribution associated context given function maps values covariates distribution \\(S\\), state space. Following original paper, mixvlmc uses multinomial logistic regression implemented VGAM::vglm() nnet::multinom(), logistic regression provided stats::glm() state spaces 2 states. several advantages general solution: estimation phase, one probability distribution estimated relevant context: induce large computational burden complex models multinomial logistic ones; simple model enables fit contexts limited number occurrences important allow searching long term dependencies; logistic models different memory order easy compare using likelihood-ratio test. last point used mixvlmc (original paper) simplify local models respect covariates. context length \\(l\\), probability distribution assumed depend \\(l\\) past values \\(\\mathbf{Y}\\) practice allow dependency \\(k<l\\) past values. instance, \\[ \\mathbb{P}(X_t=1\\mid X_{t-1}=1, X_{t-2}=1, Y_{t_1}=y_{t-1}, Y_{t_2}=y_{t-2})=g\\left(\\alpha^{1,1}+y_{t-1}\\beta^{1,1}_1\\right). \\]","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"beta-context-algorithm","dir":"Articles","previous_headings":"Theoretical aspects","what":"Beta-Context algorithm","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"Estimating COVLMC model two time series complex estimating VLMC model. mixvlmc implements Beta-Context algorithm proposed original paper. inspired context algorithm used VLMC (proposed Variable length Markov chains). can summarized follows: first step consists building context tree (see vignette(\"context-trees\")) \\(\\mathbf{X}\\) discrete sequences, almost exactly VLMC: difference kept tree context must appear number times depends length, dimension covariates number states. guarantees minimal number observations (maximum likelihood) estimation context dependant multinomial logistic regression. second step estimation one: multinomial logistic regression model estimated context, using number past values \\(\\mathbf{Y}\\) equal length context. leaf contexts first assessed terms model simplification. likelihood-ratio test used decide whether oldest value \\(\\mathbf{Y}\\) relevant . Essentially compare e.g. \\(g\\left(\\alpha^{1,1}+y_{t-1}\\beta^{1,1}_1\\right)\\) \\(g\\left(\\alpha^{1,1}+y_{t-1}\\beta^{1,1}_1+y_{t-2}\\beta^{1,1}_2\\right)\\) estimator \\(\\mathbb{P}(X_t=1\\mid X_{t-1}=1, X_{t-2}=1, Y_{t_1}=y_{t-1}, Y_{t_2}=y_{t-2})\\); based results tests, may possible completely remove context tree, see paper details. last pruning phase carried repeatedly context removals turn internal contexts leaves can simplified.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"estimation","dir":"Articles","previous_headings":"COVLMC in practice","what":"Estimation","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"COVLMC estimation provided covlmc() function. build first simple example data set follows: estimate COVLMC follows: estimation process controlled three parameters: max_depth: largest order/memory considered COVLMC (defaults 100). parameter essentially computational burden control parameter. play major role COVLMC estimation constraints imposed min_size. default value conservative; min_size: parameter controls minimal number occurrences needed context included initial context tree. gives number occurrences per parameter logistic model depends length context, dimension covariates number states; alpha: parameter pruning process Beta-Context algorithm. Pruning decisions based likelihood ratio tests alpha common level tests. default parameters work well previous example, shown obtained model: model 2 contexts, 0 1, expected. logistic models described parameters. context 0, intercept negative coefficient \\(y_{t-1}\\) positive: probability switching 1 small \\(y_{t-1}\\) small increases \\(y_{t-1}\\). context 1, situation reversed effect \\(y_{t-1}\\) smaller. consistent way series constructed. Notice however obtained interesting model default parameters seen general property proper model choice must implemented.","code":"set.seed(0) nb_obs <- 200 covariates <- data.frame(y = runif(nb_obs)) x <- 0 for (k in 2:nb_obs) {   ## we induce a simple dependency to the covariate   ## and an order 1 memory   if (covariates$y[k - 1] < 0.5) {     if (x[k - 1] == 0) {       x[k] <- sample(c(0, 1), 1, prob = c(0.7, 0.3))     } else {       x[k] <- sample(c(0, 1), 1, prob = c(0.3, 0.7))     }   } else {     if (x[k - 1] == 0) {       x[k] <- sample(c(0, 1), 1, prob = c(0.1, 0.9))     } else {       x[k] <- sample(c(0, 1), 1, prob = c(0.5, 0.5))     }   } } model <- covlmc(x, covariates) model #> VLMC with covariate context tree on 0, 1  #>  cutoff in quantile scale: 0.05 #>  Number of contexts: 2  #>  Maximum context length: 1 draw(model, model = \"full\", p_value = FALSE) #> * #> +-- 0 ([ (I)    y_1   #> |        -2.951 6.236 ]) #> '-- 1 ([ (I)   y_1    #>          1.719 -1.881 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"model-choice","dir":"Articles","previous_headings":"COVLMC in practice","what":"Model choice","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"COVLMC estimation fits potentially large number logistic models data, use penalized likelihood approach recommended set parameters avoid overfitting. However, model choice complex case COVLMC VLMC. particular, pair cutoff()/prune() work well COVLMC VLMC (see vignette(\"variable-length-markov-chains\")). Indeed pruning process Beta-Context algorithm effects predicted easily ones Context algorithm. practice, computing largest alpha (test level) guaranteed make minimal actual pruning given COVLMC easy. subsequent cut values misleading. avoid problem therefore recommended rely tune_covlmc() function designed explore full “pruning space” associated given data set. Used artificial example , gives: resulting model one obtained properly obtained minimising BIC. tune_vlmc(), max_depth parameter automatically increased avoid using inadvertently regularisation parameter. However, min_size generally considered major influence model selection VLMC, case COVLMC. currently support mixvlmc automatic choice min_size one therefore test several values compare obtained BIC/AIC. articial case, can try instance min_size=2 follows: min_size=10 follows: see particular effect parameter simplicity problem. Let us now come back electricity consumption example described . introduce basic day/night covariate follows: fit COVLMC model selection process can represented graphically follows:  final model : shows interesting patterns: one logistic model degenerate: high context, transition low context can happen. already observed VLMC; dependency respect covariate context typical, typical, typical. case, probability stay typical context increased day time decreased (lesser extent) night. practice, means model able generate longer sequences stay typical state day night. Notice finally real world example, min_size parameter influence results. Setting smaller value change final model, shown : However, increasing parameter , e.g., 10 generates simpler weaker model show :","code":"model_tune <- tune_covlmc(x, covariates) model_tune #> VLMC with covariate context tree on 0, 1  #>  cutoff in quantile scale: 0.1236 #>  Number of contexts: 2  #>  Maximum context length: 1  #>  Selected by BIC (245.8001) with likelihood function \"truncated\" (-112.3135) draw(as_covlmc(model_tune), model = \"full\", p_value = FALSE) #> * #> +-- 0 ([ (I)    y_1   #> |        -2.951 6.236 ]) #> '-- 1 ([ (I)   y_1    #>          1.719 -1.881 ]) model_tune_2 <- tune_covlmc(x, covariates, min_size = 2) model_tune_2 #> VLMC with covariate context tree on 0, 1  #>  cutoff in quantile scale: 0.01195 #>  Number of contexts: 2  #>  Maximum context length: 1  #>  Selected by BIC (245.8001) with likelihood function \"truncated\" (-112.3135) model_tune_10 <- tune_covlmc(x, covariates, min_size = 10) model_tune_10 #> VLMC with covariate context tree on 0, 1  #>  cutoff in quantile scale: 0.1236 #>  Number of contexts: 2  #>  Maximum context length: 1  #>  Selected by BIC (245.8001) with likelihood function \"truncated\" (-112.3135) elec_cov <- data.frame(day = (pc_week_15_16$hour >= 7 & pc_week_15_16$hour <= 18)) elec_tune <- tune_covlmc(elec_dts, elec_cov) elec_tune #> VLMC with covariate context tree on low, typical, high  #>  cutoff in quantile scale: 0.007218 #>  Number of contexts: 7  #>  Maximum context length: 3  #>  Selected by BIC (2243.59) with likelihood function \"truncated\" (-1064.74) ggplot(elec_tune$results, aes(x = alpha, y = BIC)) +   geom_line() +   geom_point() draw(as_covlmc(elec_tune), model = \"full\", p_value = FALSE, with_state = TRUE) #> * #> +-- low ([ (low)   | (I)    #> |          typical | -1.491 #> |          high    | -4.487 ]) #> '-- typical #> |   +-- low ([ (low)   | (I)    #> |   |          typical | 0.4643 #> |   |          high    | -1.992 ]) #> |   '-- typical #> |   |   +-- low ([ (low)   | (I)    #> |   |   |          typical | 0.3054 #> |   |   |          high    | -2.234 ]) #> |   |   '-- typical ([ (low)   | (I)     day_1TRUE #> |   |   |              typical | 1.839   0.975     #> |   |   |              high    | -0.1823 -0.1462   ]) #> |   |   '-- high ([ (low)   | (I)    #> |   |               typical | 2.773  #> |   |               high    | 0.8473 ]) #> |   '-- high ([ (low)   | (I)   #> |               typical | 3.367 #> |               high    | 1.705 ]) #> '-- high ([ (typical) | (I)   #>             high      | 1.474 ]) elec_tune_3 <- tune_covlmc(elec_dts, elec_cov, min_size = 3) elec_tune_3 #> VLMC with covariate context tree on low, typical, high  #>  cutoff in quantile scale: 0.007218 #>  Number of contexts: 7  #>  Maximum context length: 3  #>  Selected by BIC (2243.59) with likelihood function \"truncated\" (-1064.74) elec_tune_10 <- tune_covlmc(elec_dts, elec_cov, min_size = 10) elec_tune_10 #> VLMC with covariate context tree on low, typical, high  #>  cutoff in quantile scale: 0.03454 #>  Number of contexts: 5  #>  Maximum context length: 2  #>  Selected by BIC (2260.505) with likelihood function \"truncated\" (-1088.409)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"diagnostics","dir":"Articles","previous_headings":"COVLMC in practice","what":"Diagnostics","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"package provides numerous ways analyse COVLMC. asic functions include states() returns state space model; depth() returns length longest context model; context_number() returns number contexts model. instance, large model obtained following characteristics: VLMC objects support classical statistical functions :","code":"elec_model <- as_covlmc(elec_tune) states(elec_model) #> [1] low     typical high    #> Levels: low typical high depth(elec_model) #> [1] 3 context_number(elec_model) #> [1] 7 logLik(elec_model) #> 'log Lik.' -1064.74 (df=15) AIC(elec_model) #> [1] 2159.48 BIC(elec_model) #> [1] 2243.59"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/covlmc.html","id":"contexts","dir":"Articles","previous_headings":"COVLMC in practice","what":"Contexts","title":"Variable Length Markov Chains with Covariates (COVLMC)","text":"model can explored details drawing context tree (see vignette(\"context-trees\") details) follows: draw.covlmc() function advanced VLMC counterpart. provides detailed information, particularly regarding p-values associated pruning operations. “merging” p-value corresponds replacing contexts single joint model, “collapsing” p-value associated pruning sub-contexts context. P-values associated specific models correspond reducing memory corresponding model, discarding dependency conditional probability towards oldest covariates. explore contexts programmatically way, one rely contexts() function. COVLMC contexts additional characteristics compared VLMC context trees. particular, contexts() function can report model associated context, either parameters : using models : See contexts.covlmc() details.","code":"draw(elec_model) #> * (merging (low and high): 8.121e-230) #> +-- low (0.03454 [ -1.491 #> |                  -4.487 ]) #> '-- typical (merging (low and high): 8.264e-09) #> |   +-- low (0.8447 [ 0.4643 #> |   |                 -1.992 ]) #> |   '-- typical (collapsing: 3.961e-10) #> |   |   +-- low (0.2323 [ 0.3054 #> |   |   |                 -2.234 ]) #> |   |   '-- typical (6.269e-05 [ 1.839   0.975   #> |   |   |                        -0.1823 -0.1462 ]) #> |   |   '-- high (0.6393 [ 2.773  #> |   |                      0.8473 ]) #> |   '-- high (0.1638 [ 3.367 #> |                      1.705 ]) #> '-- high (0.776 [ 1.474 ]) contexts(elec_model, model = \"coef\") #>        context         coef #> 1          low -1.49102.... #> 2 typical, low 0.464305.... #> 3 typical,.... 0.305381.... #> 4 typical,.... 1.839226.... #> 5 typical,.... 2.772588.... #> 6 typical,.... 3.367295.... #> 7         high 1.473892.... contexts(elec_model, model = \"full\") #>        context                                            model #> 1          low <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 2 typical, low <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 3 typical,.... <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 4 typical,.... <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 5 typical,.... <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 6 typical,.... <S4 class 'vglm' [package \"VGAM\"] with 37 slots> #> 7         high <S4 class 'vglm' [package \"VGAM\"] with 37 slots>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"likelihood-functions-for-markov-chains","dir":"Articles","previous_headings":"","what":"Likelihood functions for Markov chains","title":"Likelihood calculation","text":"Let us consider doubly infinite time series \\(X_{\\\\mathbb{Z}}\\) generated model \\(\\mathcal{M}\\). likelihood function associated finite observation time series, \\((x_i)_{1\\leq \\leq n}\\), \\(\\mathbb{P}_{\\mathcal{M}}(X_1=x_1,\\ldots,X_n=x_n)\\). \\(\\mathcal{M}\\) Markov chain order \\(d\\), \\[ \\mathbb{P}_{\\mathcal{M}}(X_{d+1}=x_{d+1},\\ldots,X_n=x_n)=\\prod_{=d+1}^n\\mathbb{P}_{\\mathcal{M}}(X_i=x_i|X_{-1}=x_{-1},\\ldots,X_{-d}=x_{-d}). \\] Thus know \\(x_{1\\leq \\leq n}\\) can compute likelihood \\((x_i)_{d+1\\leq \\leq n}\\). practice, comparing models different orders done using likelihood functions based subset observed time series, .e. using highest order. pointed several papers impact asymptotic results (see e.g. Garivier, . (2006), Consistency unlimited BIC context tree estimator. IEEE Transactions Information Theory, 52 (10) 4630–4635).","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"truncated-solution","dir":"Articles","previous_headings":"Likelihood functions for VLMC","what":"Truncated solution","title":"Likelihood calculation","text":"simplest way define likelihood function VLMC consider Markov chain order given length longest context (.e. order VLMC).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"specific-contexts","dir":"Articles","previous_headings":"Likelihood functions for VLMC","what":"Specific contexts","title":"Likelihood calculation","text":"Another approach considers fact past \\((x_i)_{1\\leq \\leq n}\\) unknown replace collection specific contexts summarize unknown past. used Garivier’s paper cited . definition, observation actual context VLMC appears thus perfectly predicted empirical distribution associated . therefore likelihood 1. practice, amounts identifying \\(\\mathbb{P}_{\\mathcal{M}}(X_1=x_1,\\ldots,X_n=x_n)\\) \\(\\mathbb{P}_{\\mathcal{M}}(X_{d+1}=x_{d+1},\\ldots,X_n=x_n)\\). terms parameters AIC/BIC calculation, corresponds adding specific distribution \\(d\\) initial values, \\(d\\) order VLMC.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"extended-contexts","dir":"Articles","previous_headings":"Likelihood functions for VLMC","what":"Extended contexts","title":"Likelihood calculation","text":"Another approach considers extended/approximate contexts \\(d\\) initial values. Indeed observation \\(x_i\\) \\(1\\leq \\leq d\\) can considered context partially determined \\((x_1,\\ldots, x_{-1})\\) (thus empty context \\(=1\\)). Let us consider instance \\(x_1\\) empty context (root context tree). \\(d\\geq 1\\), determine context \\(x_1\\) without values \\((x_{-d+1},\\ldots, x_0)\\) even empty context valid one. However, can assign empty context \\(x_1\\) lack information. generally, can traverse context tree using many past values available stop corresponding node interpreted context using frequencies collected construction VLMC. terms parameters, adds VLMC additional extended context node context tree context.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"complete-example","dir":"Articles","previous_headings":"Likelihood functions for VLMC","what":"Complete example","title":"Likelihood calculation","text":"Let us revisit California earth quakes example proposed vignette(\"variable-length-markov-chains\"). model obtained follows (see vignette details): optimal model according BIC order 5 thus simple truncated log likelihood obtained considering observations starting index 6. disregard first 5 observations, .e.: corresponding log likelihood Using specific contexts amounts assuming perfect predictions first five observations. log likelihood modified, covers now full time series, .e. 6417 observations. number parameters increased significantly 5 initial values associated full conditional distribution leading total 11 parameters. extended context approach complex. first observation, use empty context, .e. root context tree. associated empirical distribution \\(\\mathbb{P}(X_1=1)=\\frac{1291}{5126+1291}\\simeq0.201\\). contribution log likelihood therefore \\(\\log \\mathbb{P}(X_1=0)\\simeq -0.225\\) first observation equal 0. root node proper context, specification associated empirical distribution contributes total number parameters model (.e. adds parameter total). second observation, \\(X_2=0\\), candidate context \\(0\\). However, \\(0\\) proper context normally look \\(X_{0}\\) older values find proper context. extended approach, consider empirical distribution values following 0 time series, given \\(\\mathbb{P}(X_1=1)=\\frac{940}{4185+940}\\simeq0.183\\). contribution observation log likelihood therefore \\(\\log \\mathbb{P}(X_1=0)\\simeq -0.203\\). addition, extended context adds parameter total. following observations \\(X_3\\), \\(X_4\\) \\(X_5\\) proper contexts contribute normal way (log) likelihood without need additional parameters. Notice number additional parameters depend initial sequence structure context tree. Notice also corresponding nodes contexts, contexts three values. contexts computed due lack older values. final value ","code":"California_centre <- data.frame(longitude = -119.449444, latitude = 37.166111) distances <- geodist(globalearthquake[, c(\"longitude\", \"latitude\")],   California_centre,   measure = \"geodesic\" ) California_earth_quakes <- globalearthquake[distances < 2e6, ] ## distances are in meters California_weeks <- rep(0, max(globalearthquake$nbweeks)) California_weeks[California_earth_quakes$nbweeks] <- 1 California_weeks_earth_quakes_model <- tune_vlmc(California_weeks) model <- as_vlmc(California_weeks_earth_quakes_model) draw(model, prob = FALSE) #> * (5126, 1291) #> +-- 0 (4185, 940) #> |   +-- 0 (3460, 725) #> |   |   '-- 0 (2883, 577) #> |   |       '-- 0 (2421, 462) #> |   |           '-- 1 (358, 103) #> |   '-- 1 (724, 215) #> '-- 1 (940, 351) California_weeks[1:5] #> [1] 0 0 0 0 0 loglikelihood(model) #> 'log Lik.' -3182.077 (df= 6, nb obs.= 6412, initial=\"truncated\") loglikelihood(model, initial = \"specific\") #> 'log Lik.' -3182.077 (df= 11, nb obs.= 6417, initial=\"specific\") loglikelihood(model, initial = \"extended\") #> 'log Lik.' -3183.052 (df= 8, nb obs.= 6417, initial=\"extended\")"},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"nested-models","dir":"Articles","previous_headings":"Monotonicity","what":"Nested models","title":"Likelihood calculation","text":"given time series, candidate VLMCs generated context algorithm follow nested structure associated pruning operation: complete context tree pruned recursively order generate less less complex trees. context small tree also suffix context larger tree. inclusion order total unless cut values identical. natural expected property likelihood functions observe decrease likelihood given time series switching model \\(m_1\\) simpler model \\(m_2\\) provided parameters estimated maximum likelihood using time series, particular \\(m_2\\) nested \\(m_1\\) sense likelihood-ratio test.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"theoretical-analysis","dir":"Articles","previous_headings":"Monotonicity","what":"Theoretical analysis","title":"Likelihood calculation","text":"Let us consider case two VLMC models \\(m_1\\) \\(m_2\\) \\(m_2\\) obtained pruning \\(m_1\\) (estimated \\((x_i)_{1\\leq \\leq n}\\)). Let us first consider \\((x_i)_{>d}\\) \\(d\\) order \\(m_1\\). contexts values well defined, \\(m_1\\) \\(m_2\\). corresponding probabilities can factorised according contexts follows (\\(m_1\\)) \\[ \\mathbb{P}_{m_1}(X_{d+1}=x_{d+1},\\ldots,X_n=x_n)=\\prod_{c\\m_1}\\prod_{k,\\  ctx(m_1, x_k)=c}\\mathbb{P}_{m_1}(X_k=x_k|ctx(m_1, x_k)=c), \\] use \\(ctx(m_1, x_k)\\) denote context \\(x_k\\) \\(m_1\\) \\(c\\m_1\\) denote contexts \\(m_1\\). obviously similar equation \\(m_2\\). \\(m_2\\) included \\(m_1\\) know \\(c\\m_2\\) also suffix context \\(m_1\\). \\(c\\) context models, concern subset time series use therefore estimated conditional probabilities, leading identical values \\[\\mathbb{P}_{m_1}(X_k=x_k|ctx(m_1, x_k)=c)=\\mathbb{P}_{m2}(X_k=x_k|ctx(m_2, x_k)=c).\\] \\(c\\) suffix context \\(m_1\\), collection contexts \\(c'\\) \\(c\\) also suffix. \\[ \\{k\\mid ctx(m_2, x_k)=c\\}=\\bigcup_{c'\\m_1, c\\text{ suffix }c'}\\{j\\mid ctx(m_1, x_j)=c'\\}. \\] words, collection observations whose context \\(m_1\\) \\(c\\) suffix equal collection observations chose context \\(m_2\\) \\(c\\). conditional probabilities estimated maximum likelihood, \\[ \\begin{multline*} \\prod_{\\{k\\mid ctx(m_2, x_k)=c\\}}\\mathbb{P}_{m_2}(X_k=x_k|ctx(m_2, x_k)=c)\\leq\\\\ \\prod_{\\{l\\mid ctx(m_1, x_k)=c', c\\text{ suffix }c'\\}}\\mathbb{P}_{m_1}(X_l=x_l|ctx(m_1, x_k)=c'). \\end{multline*} \\] Thus overall, expected, \\[ \\mathbb{P}_{m_2}(X_{d+1}=x_{d+1},\\ldots,X_n=x_n)\\leq \\mathbb{P}_{m_1}(X_{d+1}=x_{d+1},\\ldots,X_n=x_n). \\] However, models may order. Fortunately, probabilities larger 1, also \\[ \\mathbb{P}_{m_2}(X_{d_{m_2}+1}=x_{d_{m_2}+1},\\ldots,X_n=x_n)\\leq \\mathbb{P}_{m_1}(X_{d_{m_1}+1}=x_{d_{m_1}+1},\\ldots,X_n=x_n), \\] \\(d_m\\) denotes order model \\(m\\). conclusion, likelihood functions based truncation specific contexts non increasing one moves VLMC one pruned version. case extended contexts complex. Using hypotheses , extended likelihood includes approximate contexts observations \\(x_{1},\\ldots, x_{d_{m_1}}\\) \\(x_{1},\\ldots, x_{d_{m_2}}\\). Let us consider case \\(d_{m_1}=d_{m_2}+1\\) (without loss generality). difference extended likelihoods \\(\\mathbb{P}_{m_1}(X_{d_{m_1}}=x_{d_{m_1}}|ectx(m_1, x_{d_{m_1}}))\\) computed using extended context \\(ectx(m_1, X_{d_{m_1}})\\) \\(\\mathbb{P}_{m_2}(X_{d_{m_1}}=x_{d_{m_1}}|ctx(m_2, x_{d_{m_1}}))\\) computed using true context. Notice \\[ (x_1,\\ldots,x_{d_{m_1}-1},x_{d_{m_1}})=(x_1,\\ldots,x_{d_{m_2}-1},x_{d_{m_2}}, x_{d_{m_1}}) \\] Thus one computes (extended) context \\(x_{d_{m_1}}\\), \\(d_{m_2}\\) first steps obviously identical \\(m_1\\) \\(m_2\\), \\(m_2\\) obtained pruning \\(m_1\\). Depending structure context tree, may possible possible determine true context \\(x_{d_{m_1}}\\) trees thus corresponding probabilities identical. non obvious situation context \\(x_{d_{m_1}}\\) determine \\(m_1\\). possible context \\(m_2\\) length \\(d_{m_2}\\) corresponding leaf internal node \\(m_1\\). use extended context \\(m_1\\) normal context \\(m_2\\) therefore \\[ \\mathbb{P}_{m_1}(X_{d_{m_1}}=x_{d_{m_1}}|ectx(m_1, x_{d_{m_1}}))=\\mathbb{P}_{m_2}(X_{d_{m_1}}=x_{d_{m_1}}|ctx(m_2, x_{d_{m_1}})). \\] Thus cases, extended context interpretation, moving extended context true context change probability included likelihood. Therefore, extended likelihood also non increasing pruning operation.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/likelihood.html","id":"experimental-illustration","dir":"Articles","previous_headings":"Monotonicity","what":"Experimental illustration","title":"Likelihood calculation","text":"default, tune_vlmc() uses truncated likelihood thus California earth quakes results can used illustrate non increasing behaviour follows:  noted , numerical values specific likelihood identical thus graphical representation also valid . extended likelihood can used tune_vlmc() follows: gives following log likelihood representation: Notice time series contains 6417 observations maximum order considered tune_vlmc() 29, thus expect observe large differences different log likelihoods. illustrated following figure:","code":"ggplot(California_weeks_earth_quakes_model$results, aes(cutoff, loglikelihood)) +   geom_line() +   xlab(\"Cut off (native scale)\") +   ylab(\"Log likelihood\") +   ggtitle(\"Truncated log likelihood\") California_weeks_earth_quakes_model_extended <-   tune_vlmc(California_weeks, initial = \"extended\") ggplot(   California_weeks_earth_quakes_model_extended$results,   aes(cutoff, loglikelihood) ) +   geom_line() +   xlab(\"Cut off (native scale)\") +   ylab(\"Log likelihood\") +   ggtitle(\"Extended log likelihood\") CW_combined <- rbind(   California_weeks_earth_quakes_model$results[c(\"cutoff\", \"loglikelihood\")],   California_weeks_earth_quakes_model_extended$results[c(\"cutoff\", \"loglikelihood\")] ) CW_combined[[\"Likelihood function\"]] <- rep(c(\"truncated\", \"extended\"), times = rep(nrow(California_weeks_earth_quakes_model$results), 2)) ggplot(   CW_combined,   aes(cutoff, loglikelihood, color = `Likelihood function`) ) +   geom_line() +   xlab(\"Cut off (native scale)\") +   ylab(\"Log likelihood\") +   ggtitle(\"Log likelihood\")"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"theoretical-results","dir":"Articles","previous_headings":"","what":"Theoretical results","title":"Sampling from (CO)VLMC","text":"Bühlmann Wyner show paper approach consistent statistics depend smoothly arbitrary means fixed mappings contexts numerical values. simple terms, one can first choose mapping arbitrary tuples values state space numerical vectors build estimator averaging vectors observed sequence. resulting vector mean can transformed smoothly lead estimator. VLMC bootstrap consistent estimator relatively mild hypothesis underlying VLMC. typical example estimator probability observing fixed pattern sequence. generally, class estimators includes smooth transformations empirical distribution patterns fixed length. practice, recommended sample longer sequence one needed keep last \\(n\\) values, order minimise influence starting values.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"introduction","dir":"Articles","previous_headings":"Sampling from a VLMC","what":"Introduction","title":"Sampling from (CO)VLMC","text":"Let us consider simple example independent sample: optimal VLMC according BIC non memory: Simulating sequence using model done via standard stats::simulate() function follows: Even useless independence, drop first 100 samples. general simulate.vlmc() used stats::simulate() supports standard parameters: nsim number simulated values, length new time series seed specify random seed used simulation (initial state random number generator restored previous simulating values) addition, one can specify initial values sequence via init parameter, instance: guaranteed start \\(0, 0\\): provides alternative dropping initial values simulated time series setting values one observed data set. Notice practice theoretical justification.","code":"dts <- sample(0:1, 500, replace = TRUE) best_vlmc <- tune_vlmc(dts) draw(as_vlmc(best_vlmc)) #> * (0.494, 0.506) dts_sample <- simulate(as_vlmc(best_vlmc), 600)[-(1:100)] dts_sample_2 <- simulate(as_vlmc(best_vlmc), 10, init = c(0L, 0L)) dts_sample_2 #>  [1] 0 0 1 0 0 1 0 0 0 0"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"cac-time-series","dir":"Articles","previous_headings":"Sampling from a VLMC","what":"CAC time series","title":"Sampling from (CO)VLMC","text":"Let us consider French CAC index provided EuStockMarkets: turn discrete time series three values: Stay value index day t+1 99.5% 100.5% value day t value increased least 0.5% value decreased least 0.5% adjust VLMC time series using AIC criterion: use AIC favour predictive performances consequence obtained model quite complex 7 contexts. original discrete time series exhibit long subsequences constant values shown following graphical representation.  study aspect time series, natural statistics probability observing constant subsequence length 5 10 among subsequences length 10 can generated model. Notice patterns used statistics must fixed lengths covered consistency theorems mentioned . implement statistics follows: generate 100 bootstrap samples, using burning time proportional depth model, order allow proper mixing take place. use seed parameter stats::simulate() ensure reproducibility. compute statistics bootstrap samples. bootstrap distribution statistics illustrated following figure red vertical line represents value statistics original sequence.","code":"CAC_raw <- as.data.frame(EuStockMarkets)$CAC CAC_rel_evol <- diff(CAC_raw) / CAC_raw[-length(CAC_raw)] CAC_dts <- factor(   ifelse(CAC_rel_evol >= 0.005, \"Up\",     ifelse(CAC_rel_evol <= -0.005, \"Down\", \"Stay\")   ),   levels = c(\"Down\", \"Stay\", \"Up\") ) CAC_vlmc <- tune_vlmc(CAC_dts, criterion = \"AIC\") CAC_model <- as_vlmc(CAC_vlmc) CAC_rle <- rle(as.integer(CAC_dts)) CAC_rle_df <- data.frame(value = CAC_rle$values, length = CAC_rle$lengths) ggplot(CAC_rle_df, aes(x = length)) +   geom_bar() +   labs(     title = \"Distribution of the lengths of constant subsequences\",     x = \"Length\",     y = \"Count\"   ) long_sequence <- function(dts) {   dts_int <- as.integer(dts)   ## RLE cannot be used directly as we need to account for overlapping   ## patterns   dts_freq <- frollapply(dts_int, 10, \\(x) max(rle(x)$length) >= 5)   mean(dts_freq, na.rm = TRUE) } bootstrap_samples <- vector(100, mode = \"list\") burning_time <- 50 * depth(CAC_model) for (b in seq_along(bootstrap_samples)) {   bootstrap_samples[[b]] <- simulate(CAC_model,     burning_time + length(CAC_dts),     seed = b   )[-(1:burning_time)] } bootstrap_ls <- sapply(bootstrap_samples, long_sequence) ggplot(mapping = aes(x = bootstrap_ls)) +   geom_density() +   geom_rug() +   labs(     title = \"Bootstrap distribution of the probability of long constant subsequences\",     x = \"Probability\"   ) +   geom_vline(xintercept = long_sequence(CAC_dts), color = \"red\")"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"sampling-from-a-covlmc","dir":"Articles","previous_headings":"","what":"Sampling from a COVLMC","title":"Sampling from (CO)VLMC","text":"case COVLMC complex mainly dependence towards external time series modelled. addition, theoretical result justify form COVLMC bootstrap time writing document (2023). can nevertheless use sampling get idea potential variability results qualitative point view, also study -scenarios based modification covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"cac-example-continued","dir":"Articles","previous_headings":"Sampling from a COVLMC","what":"CAC example continued","title":"Sampling from (CO)VLMC","text":"Let us study CAC discrete time series using three indexes EuStockMarkets covariates. previously, select model AIC criterion: obtained model relatively complex shown : variability discrete time series fixed values covariates can investigated using simulated sequences. difference simulate.vlmc() simulate.covlmc() need covariates latter. burning time also problematic additional throw away values covariates. possibility used consists starting discrete time series observed one started, using many values size largest context. Notice current implementation, simulating COVLMC relatively slow compared simulation VLMC. perform single simulation illustrate feature.","code":"CAC_covariates <- as.data.frame(EuStockMarkets)[c(\"DAX\", \"SMI\", \"FTSE\")][-1, ] CAC_covlmc <- tune_covlmc(CAC_dts, CAC_covariates, criterion = \"AIC\") CAC_comodel <- as_covlmc(CAC_covlmc) draw(CAC_comodel, model = \"full\", with_state = TRUE) #> * #> +-- Down #> |   +-- Down (0.04097 [ (Down) | (I)    DAX_1   SMI_1    FTSE_1    DAX_2    SMI_2   FTSE_2   #> |   |                   Stay   | -2.383 0.01467 -0.01714 -0.003948 -0.01314 0.01539 0.005337 #> |   |                   Up     | -1.939 0.02377 -0.02597 -0.0104   -0.02428 0.02526 0.01193  ]) #> |   '-- Stay, Up (0.07236 [ (Down) | (I)    DAX_1     SMI_1     FTSE_1     #> |                           Stay   | -1.412 0.0004292 -0.001297 0.001371   #> |                           Up     | 1.59   -0.000136 0.0004101 -0.0007633 ]) #> '-- Stay #> |   +-- Stay (0.0065 [ (Down) | (I)   DAX_1     SMI_1     FTSE_1  DAX_2     SMI_2    FTSE_2   #> |   |                  Stay   | 0.871 0.007903  -0.009399 0.01673 -0.007771 0.009261 -0.01684 #> |   |                  Up     | 2.838 -0.005994 -0.01448  0.0299  0.003666  0.0169   -0.03126 ]) #> |   '-- Down, Up (0.002452 [ (Down) | (I)    DAX_1     SMI_1     FTSE_1    #> |                            Stay   | -1.707 -0.001755 0.0004276 0.001412  #> |                            Up     | -1.397 -0.001357 0.0006376 0.0008178 ]) #> '-- Up #>     +-- Up (0.01046 [ (Down) | (I)     DAX_1    SMI_1    FTSE_1    DAX_2     SMI_2   FTSE_2   #>     |                 Stay   | -0.4838 0.02407  -0.02501 -0.008507 -0.02374  0.02474 0.0089   #>     |                 Up     | 2.484   0.005797 -0.01774 -0.009711 -0.006469 0.01917 0.008314 ]) #>     '-- Down, Stay (0.7881 [ (Down) | (I)    #>                              Stay   | 0.3225 #>                              Up     | 0.1779 ]) co_sample <- simulate(CAC_comodel,   length(CAC_dts),   seed = 0,   init = CAC_dts[1:depth(CAC_comodel)],   covariate = CAC_covariates )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/sampling.html","id":"what-if-scenarios","dir":"Articles","previous_headings":"Sampling from a COVLMC","what":"What-if scenarios","title":"Sampling from (CO)VLMC","text":"situations, one can modify covariates test consequences external influence discrete time series study. Let us consider instance week electrical consumption: build discrete version considering two states: background base active power 0.4 kW active use electric appliance limit. adjust COVLMC binary covariate day/night, using AIC. can simulate longer shorter days manipulating covariates. instance “day ” full week obtained follows “night ” full week given typical use approach consists simulating first collection sequences original covariates get sense variability statistics interest. second phase, comparable collection sequences generated using manipulated covariates.","code":"pc_week <- powerconsumption[powerconsumption$week == 12, ] elec <- pc_week$active_power ggplot(pc_week, aes(x = date_time, y = active_power)) +   geom_line() +   xlab(\"Date\") +   ylab(\"Activer power (kW)\") elec_dts <- cut(elec, breaks = c(0, 1.2, 8), labels = c(\"background\", \"active\")) elec_cov <- data.frame(day = (pc_week$hour >= 7 & pc_week$hour <= 17)) elec_covlmc_tune <- tune_covlmc(elec_dts, elec_cov, criterion = \"AIC\") best_elec_covlmc <- as_covlmc(elec_covlmc_tune) draw(best_elec_covlmc, model = \"full\", time_sep = \" | \", p_value = FALSE) #> * #> +-- background #> |   +-- background ([ (I)    | day_1TRUE #> |   |                 -3.383 | 0.8979    ]) #> |   '-- active ([ (I)    #> |                 -1.526 ]) #> '-- active #>     +-- background ([ (I)   | day_1TRUE #>     |                 20.57 | -19.36    ]) #>     '-- active #>         +-- background ([ (I)   #>         |                 1.609 ]) #>         '-- active ([ (I)   | day_1TRUE #>                       2.552 | 0.8602    ]) day_only <- simulate(best_elec_covlmc,   length(elec_dts),   seed = 0,   covariate = data.frame(day = rep(TRUE, length(elec_dts))) ) night_only <- simulate(best_elec_covlmc,   length(elec_dts),   seed = 0,   covariate = data.frame(day = rep(FALSE, length(elec_dts))) )"},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"high-order-markov-chains","dir":"Articles","previous_headings":"Theoretical aspects","what":"High order Markov chains","title":"Variable length Markov chains (VLMC)","text":"Let us denote \\(X_1, X_2, \\ldots, X_n, \\ldots\\) sequence random variables. (stationary) Markov chain order \\(m\\) \\(n>m\\) \\[ \\begin{multline} \\mathbb{P}(X_n=x_n|X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \\ldots, X_{1}=x_{1})=\\\\ \\mathbb{P}(X_n=x_n|X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \\ldots, X_{n-m}=x_{n-m}). \\end{multline} \\] specify Markov chain order \\(m\\), one needs describe conditional distribution right hand side previous equation values past, .e. contexts (see vignette(\"context-trees\")). state space \\(k\\) states, need \\(k-1\\) parameters specify completely \\[ \\mathbb{P}(X_n=x_n|X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \\ldots, X_{n-m}=x_{n-m}) \\] values \\(x_n\\) single context \\((x_{n-1}, x_{n-2}, \\ldots, x_{n-m})\\). \\(k^{m-1}\\) contexts thus need total \\((k-1)k^{m-1}\\) parameters specify completely Markov chain order \\(m\\) state space \\(k\\) states. Unfortunately, exponential growth respect order makes high order Markov chain unrealistic statistical point view: number parameters estimate grows quickly compared typical length time series. consider gene sequence (pair ) bases, state space \\(k=4\\) states. mean protein-coding length humans roughly 66,000 (pairs ) bases. following table shows growth parameter number \\(k=4\\) order Markov chain. already way many parameter \\(m=7\\) proper estimation based single gene average length. Even longest genes insufficient \\(m=10\\).","code":"#>     m parameters #> 1   1         12 #> 2   2         48 #> 3   3        192 #> 4   4        768 #> 5   5       3072 #> 6   6      12288 #> 7   7      49152 #> 8   8     196608 #> 9   9     786432 #> 10 10    3145728"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"sparse-models","dir":"Articles","previous_headings":"Theoretical aspects","what":"Sparse models","title":"Variable length Markov chains (VLMC)","text":"higher order Markov chains useful capture long memory time series, exponential growth parameter space incompatible goal. Variable length Markov chains provide compromise controlled number parameters low order Markov chains long memory high order ones. key idea consider dependency order can depend context . Let us consider simple example binary valued time series (\\(k=2\\)) Markov chain order 3. need specify instance probability \\(X_n=1\\) given eight possible contexts, \\((0, 0, 0)\\) \\((1, 1, 1)\\). possible choice table, several contexts share conditional probability distribution. instance \\[ \\mathbb{P}(X_n=1|X_{n-1}=0, X_{n-2}=0,X_{n-3}=0)=\\mathbb{P}(X_n=1|X_{n-1}=0, X_{n-2}=1,X_{n-3}=0). \\] fact, careful look table shows \\[ \\begin{align*} \\mathbb{P}(X_n=1|X_{n-1}=0, X_{n-2}=, X_{n-3}=b)&=0.1&\\forall , \\forall b,\\\\ \\mathbb{P}(X_n=1|X_{n-1}=1, X_{n-2}=1, X_{n-3}=c)&=0.3&\\forall c,\\\\ \\mathbb{P}(X_n=1|X_{n-1}=1, X_{n-2}=0, X_{n-3}=0)&=0.2,&\\\\ \\mathbb{P}(X_n=1|X_{n-1}=1, X_{n-2}=0, X_{n-3}=1)&=0.4, \\end{align*} \\] thus Markov chain can described 4 probability distributions rather 8. corresponding contexts : \\((0)\\) : short memory last state 0 \\((1, 1)\\) : second order memory two last states 1 \\((1, 0, 0)\\) \\((1, 0, 1)\\) : full third order memory third order Markov chain parsimonious sense can described four contexts associated probability distributions rather full collection needed arbitrary third order Markov chain.","code":"#>   Probablity n-1 n-2 n-3 #> 1        0.1   0   0   0 #> 2        0.2   1   0   0 #> 3        0.1   0   1   0 #> 4        0.3   1   1   0 #> 5        0.1   0   0   1 #> 6        0.4   1   0   1 #> 7        0.1   0   1   1 #> 8        0.3   1   1   1"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"variable-length-markov-chain","dir":"Articles","previous_headings":"Theoretical aspects","what":"Variable length Markov chain","title":"Variable length Markov chains (VLMC)","text":"variable length Markov chain (VLMC) sparse high order Markov chain. Let us denote \\(X_1, X_2, \\ldots, X_n, \\ldots\\) sequence random variables taking values finite state space \\(S\\). sequence VLMC maximal order \\(l_{\\max}\\) function \\(l\\) \\(S^{l_{\\max}}\\) \\(\\{0,\\ldots,l_{\\max}\\}\\) \\(n>l_{\\max}\\) \\[ \\begin{multline} \\mathbb{P}(X_n=x_n|X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \\ldots, X_{1}=x_{1})=\\\\ \\mathbb{P}(X_n=x_n|X_{n-1}=x_{n-1}, X_{n-2}=x_{n-2}, \\ldots, X_{n-l(x_{n-1},\\ldots,x_{n-l_{\\max}})}=x_{n-l(x_{n-1},\\ldots,x_{n-l_{\\max}})}). \\end{multline} \\] words, memory length (order) variable given \\(l(x_{n-1},\\ldots,x_{n-l_{\\max}})\\). memory length function generates context function \\(c\\) keeps past part needed obtain conditional distribution: \\(c\\) function \\(S^{l_{\\max}}\\) \\(\\bigcup_{k=0}^{l_{\\max}}S^k\\) given : \\[ c(x_1, x_2, \\ldots, x_{l_{\\max}})=(x_1,\\ldots,x_{l(x_1, x_2, \\ldots, x_{l_{\\max}})}) \\] image \\(c\\) \\(S^{l_{\\max}}\\) set contexts VLMC entirely specified \\(l\\) one conditional distribution unique context. example, \\(l_{\\max}=3\\) \\(l\\) defined \\(\\{0, 1\\}^3\\) \\(\\{0, 1, 2, 3\\}\\) \\[ \\begin{align*} l(0, , b)&=1&\\forall , \\forall b,\\\\ l(1, 1, c)&=2&\\forall c,\\\\ l(1, 0, 0)&=3,&\\\\ l(1, 0, 1)&=3.&\\\\ \\end{align*} \\]","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"vlmc-estimation","dir":"Articles","previous_headings":"Theoretical aspects","what":"VLMC estimation","title":"Variable length Markov chains (VLMC)","text":"assume observed time series generated VLMC, can try estimate \\(l\\) function corresponding conditional probabilities. non-parametric estimation problem \\(l_{\\max}\\) unknown. natural way carry estimation use form penalized likelihood approach. done first extracting time series context tree (see vignette(\"context-trees\")), sparse representation sub-sequences (.e. contexts) appear least times time series. unique sub-sequence/context followed state time series: used estimate conditional probabilities (frequencies). Finally pruning algorithm applied balance complexity tree likelihood (given time series).","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"estimation","dir":"Articles","previous_headings":"VLMC in practice","what":"Estimation","title":"Variable length Markov chains (VLMC)","text":"VLMC estimation provided vlmc() function following example. estimation process controlled three parameters: max_depth: largest order/memory considered VLMC (defaults 100). parameter essentially computational burden control parameter increased larger value final model contexts reach maximum value (done automatically tune_vlmc()); min_size: minimum number occurrences context time series included context tree first phase algorithm. default 2 value conservative. Larger values produce simpler trees; alpha/cutoff: main complexity control parameter, can expressed two different scales. cutoff expressed native Kullback-Liebler divergence scale used assess difference conditional probability distributions given different contexts. alpha expressed convenient universal scale based quantiles Chi-Squared distribution appears pruning criterion interpreted likelihood ratio test (default alpha=0.05). recommended use default value min_size, increase max_depth case “overflow” (.e. maximum context length reaches max_depth) use alpha control complexity VLMC, preferably automatically tune_vlmc(). important point note higher value alpha leads complex model lower value cutoff. Based theoretical results, order magnitude cutoff \\(K \\log n\\) (\\(n\\) observations), \\(K\\) depends type convergence analysis conducted. instance BIC inspired value \\(K\\) \\((|S|-1)/2\\) state space \\(S\\) (size \\(|S|\\)). example, get: result memory less model, expected based way x generated. situation, chosen value cutoff leads optimal model, always case choice informed asymptotic analysis.","code":"set.seed(0) x <- sample(c(0L, 1L, 2L), 200, replace = TRUE) model <- vlmc(x) model #> VLMC context tree on 0, 1, 2  #>  cutoff: 2.996 (quantile: 0.05) #>  Number of contexts: 4  #>  Maximum context length: 3 model_theo <- vlmc(x, cutoff = log(length(x))) model_theo #> VLMC context tree on 0, 1, 2  #>  cutoff: 5.298 (quantile: 0.005) #>  Number of contexts: 1  #>  Maximum context length: 0"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"model-choice","dir":"Articles","previous_headings":"VLMC in practice","what":"Model choice","title":"Variable length Markov chains (VLMC)","text":"practice, recommended start conservative value cutoff (alpha) use penalized criterion find best model way balances likelihood complexity (see vignette(\"likelihood\") details likelihood calculation VLMC). conservative value cutoff small one, alpha high conservative. possible choice use BIC inspired cutoff divided fixed value, instance \\(\\frac{1}{4}(|S|-1)\\log n\\). “large” model obtained, two functions can used generate collection simpler models obtained using larger values cutoff. function cutoff() returns list values (alpha scale default) guaranteed contain values can generate simpler models reference one. instance following code first adjust “complex” model using `cutoff=`2.65 find 2 values can used build simpler models, using prune() follows: final model model_small memory less model.","code":"model_large <- vlmc(x, cutoff = 0.5 * log(length(x))) model_large #> VLMC context tree on 0, 1, 2  #>  cutoff: 2.649 (quantile: 0.07071) #>  Number of contexts: 6  #>  Maximum context length: 3 model_cutoff <- cutoff(model_large, mode = \"native\") model_cutoff #> [1] 3.177898 3.784875 model_medium <- prune(model_large, cutoff = model_cutoff[1]) model_medium #> VLMC context tree on 0, 1, 2  #>  cutoff: 3.178 (quantile: 0.04167) #>  Number of contexts: 4  #>  Maximum context length: 3 model_small <- prune(model_large, cutoff = model_cutoff[2]) model_small #> VLMC context tree on 0, 1, 2  #>  cutoff: 3.785 (quantile: 0.02271) #>  Number of contexts: 1  #>  Maximum context length: 0"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"automatic-model-choice","dir":"Articles","previous_headings":"VLMC in practice","what":"Automatic model choice","title":"Variable length Markov chains (VLMC)","text":"pair cutoff()/prune() can used implement advanced model selection techniques, instance based quality predictions model hold-example. standard use, tune_vlmc() provides fully automated solution, including choice conservative values initial cut large enough max_depth, demonstrated : obtain directly optimal model according BIC criterion.","code":"model_tune <- tune_vlmc(x) model_opt <- as_vlmc(model_tune) model_opt #> VLMC context tree on 0, 1, 2  #>  cutoff: 3.785 (quantile: 0.02271) #>  Number of contexts: 1  #>  Maximum context length: 0"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"model-choice-representation","dir":"Articles","previous_headings":"VLMC in practice","what":"Model choice representation","title":"Variable length Markov chains (VLMC)","text":"object returned tune_vlmc() contains summary fitting process. Let us consider realistic example using globalearthquake data set included package. simple example extract data set earth quakes took place within 2,000 km radius around centre California. study collection week level, building binary sequence weeks without earthquake(s). finally adjust automatically VLMC. resulting model remains relatively simple interesting increase risk observing earth quake 6 weeks last one. tuning process can summarised using summary() function follows. addition, summary data frame accessible results component object. can used build e.g. graphical representation model selection process instance follows","code":"California_centre <- data.frame(longitude = -119.449444, latitude = 37.166111) distances <- geodist(globalearthquake[, c(\"longitude\", \"latitude\")],   California_centre,   measure = \"geodesic\" ) California_earth_quakes <- globalearthquake[distances < 2e6, ] ## distances are in meters California_weeks <- rep(0, max(globalearthquake$nbweeks)) California_weeks[California_earth_quakes$nbweeks] <- 1 California_weeks_earth_quakes_model <- tune_vlmc(California_weeks) draw(as_vlmc(California_weeks_earth_quakes_model)) #> * (0.7988, 0.2012) #> +-- 0 (0.8166, 0.1834) #> |   +-- 0 (0.8268, 0.1732) #> |   |   '-- 0 (0.8332, 0.1668) #> |   |       '-- 0 (0.8398, 0.1602) #> |   |           '-- 1 (0.7766, 0.2234) #> |   '-- 1 (0.771, 0.229) #> '-- 1 (0.7281, 0.2719) summary(California_weeks_earth_quakes_model) #> VLMC tune results #>  #> Best VLMC selected by BIC (6416.75) with likelihood function \"truncated\" (-3182.077) #> VLMC context tree on 0, 1  #>  cutoff: 6.041 (quantile: 0.0005092) #>  Number of contexts: 6  #>  Maximum context length: 5  #>  #> Pruning results #>     cutoff        alpha depth nb_contexts loglikelihood      AIC      BIC #>   2.191676 3.629154e-02    29         152     -3040.206 6384.411 7412.262 #>   2.201782 3.586391e-02    29         139     -3046.470 6370.940 7310.883 #>   2.228217 3.477002e-02    29         132     -3051.316 6366.632 7259.239 #>   2.279152 3.275949e-02    29         132     -3053.566 6371.133 7263.740 #>   2.339072 3.054872e-02    29         132     -3055.875 6375.750 7268.357 #>   2.372521 2.938285e-02    29         132     -3058.245 6380.490 7273.097 #>   2.381973 2.906186e-02    29         131     -3062.226 6386.452 7272.297 #>   2.394852 2.863036e-02    29         130     -3066.502 6393.004 7272.087 #>   2.404277 2.831881e-02    29         127     -3069.036 6392.071 7250.868 #>   2.416055 2.793443e-02    29         116     -3072.629 6377.258 7161.671 #>   2.445039 2.701147e-02    29         114     -3076.648 6381.296 7152.184 #>   2.506516 2.515721e-02    29         110     -3080.985 6381.970 7125.810 #>   2.577905 2.316872e-02    29         110     -3083.533 6387.066 7130.905 #>   2.625968 2.192238e-02    29         108     -3088.617 6393.233 7123.548 #>   2.751151 1.899146e-02    29         103     -3093.269 6392.538 7089.042 #>   2.893754 1.614045e-02    29         103     -3096.132 6398.264 7094.769 #>   3.125676 1.240985e-02    29         103     -3099.057 6404.114 7100.618 #>   3.344228 9.703925e-03    29          95     -3106.293 6402.587 7044.993 #>   3.417970 8.934162e-03    27          90     -3111.312 6402.623 7011.247 #>   3.536173 7.828270e-03    27          87     -3115.617 6405.234 6993.570 #>   3.737381 6.256985e-03    27          63     -3127.233 6380.466 6806.503 #>   4.077262 4.295389e-03    27          45     -3134.734 6359.469 6663.781 #>   4.382147 3.071849e-03    27          43     -3139.382 6364.765 6655.552 #>   4.507405 2.678006e-03    10          26     -3147.436 6346.873 6522.767 #>   4.628051 2.347121e-03    10          21     -3153.579 6349.158 6491.226 #>   4.763629 2.024423e-03    10          14     -3159.154 6346.308 6441.020 #>   5.090995 1.418191e-03     7          11     -3165.635 6353.270 6427.692 #>   5.678601 7.515599e-04     7           8     -3173.956 6363.911 6418.036 #>   6.040782 5.092285e-04     5           6     -3182.077 6376.155 6416.750 #>   6.183282 4.370913e-04     5           6     -3188.213 6388.425 6429.021 #>  10.764714 3.484403e-06     1           2     -3202.770 6409.540 6423.073 #>  26.426030 3.596414e-13     0           1     -3221.590 6445.180 6451.947 ggplot(California_weeks_earth_quakes_model$results, aes(x = alpha, y = BIC)) +   geom_line() +   geom_point()"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"diagnostics","dir":"Articles","previous_headings":"VLMC in practice","what":"Diagnostics","title":"Variable length Markov chains (VLMC)","text":"package provides numerous ways analyse VLMC. Basic functions include states() returns state space model; depth() returns length longest context model; context_number() returns number contexts model. instance, large model obtained following characteristics: VLMC objects support classical statistical functions :","code":"states(model_large) #> [1] 0 1 2 depth(model_large) #> [1] 3 context_number(model_large) #> [1] 6 logLik(model_large) #> 'log Lik.' -207.4279 (df=12) AIC(model_large) #> [1] 438.8558 BIC(model_large) #> [1] 478.2542"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/articles/variable-length-markov-chains.html","id":"contexts","dir":"Articles","previous_headings":"VLMC in practice","what":"Contexts","title":"Variable length Markov chains (VLMC)","text":"model can explored details drawing context tree (see vignette(\"context-trees\") details) follows: explore contexts programmatic way, one rely contexts() function. VLMC contexts additional characteristics compared context trees. particular, contexts() function can report log likelihood ratio associated context follows (compare cutoff() ): Notice default contexts() uses reverse representation contexts, can returned natural time sequence using reverse=FALSE, ","code":"draw(model_large) #> * (0.325, 0.345, 0.33) #> '-- 1 (0.3043, 0.4203, 0.2754) #>     +-- 1 (0.2069, 0.4828, 0.3103) #>     |   '-- 0 (0.2222, 0.7778, 0) #>     '-- 2 (0.3, 0.3, 0.4) #>         '-- 2 (0, 0.375, 0.625) contexts(model_large, cutoff = \"native\") #>   context    cutoff #> 1 1, 1, 0 3.4813864 #> 2    1, 1 0.7006631 #> 3 1, 2, 2 2.9008662 #> 4    1, 2 0.8777091 #> 5       1 0.9067789 #> 6         0.0000000 contexts(model_large, cutoff = \"quantile\", reverse = FALSE, frequency = \"detailed\") #>   context freq  0  1  2     cutoff #> 1 0, 1, 1    9  2  7  0 0.03076473 #> 2    1, 1   29  6 14  9 0.49625611 #> 3 2, 2, 1    8  0  3  5 0.05497558 #> 4    2, 1   20  6  6  8 0.41573421 #> 5       1   69 21 29 19 0.40382287 #> 6          200 65 69 66 1.00000000"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Fabrice Rossi. Author, maintainer, copyright holder. Hugo Le Picard. Contributor. Guénolé Joubioux. Contributor.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rossi F (2023). mixvlmc: Variable Length Markov Chains Covariates. https://github.com/fabrice-rossi/mixvlmc, https://fabrice-rossi.github.io/mixvlmc/.","code":"@Manual{,   title = {mixvlmc: Variable Length Markov Chains with Covariates},   author = {Fabrice Rossi},   year = {2023},   note = {https://github.com/fabrice-rossi/mixvlmc, https://fabrice-rossi.github.io/mixvlmc/}, }"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"variable-length-markov-chains-with-covariates","dir":"","previous_headings":"","what":"Variable Length Markov Chains with Covariates","title":"Variable Length Markov Chains with Covariates","text":"mixvlmc implements variable length Markov chains (VLMC) variable length Markov chains covariates (COVLMC), described : Bühlmann, P. Wyner, . J. (1999), Variable length Markov chains. Ann. Statist. 27 (2) 480-513 Zanin Zambom, ., Kim, S. Lopes Garcia, N. (2022), Variable length Markov chain exogenous covariates. J. Time Ser. Anal., 43 (2) 312-328 mixvlmc includes functionalities similar ones available VLMC PST. main advantages mixvlmc support time varying covariates COVLMC introduction post-pruning models enables fast model selection via information criteria.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Variable Length Markov Chains with Covariates","text":"package can installed CRAN : development version available GitHub:","code":"install.packages(\"mixvlmc\") # install.packages(\"devtools\") devtools::install_github(\"fabrice-rossi/mixvlmc\")"},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"variable-length-markov-chains","dir":"","previous_headings":"Usage","what":"Variable length Markov chains","title":"Variable Length Markov Chains with Covariates","text":"Variable length Markov chains (VLMC) sparse high order Markov chains. can used model time series (sequences) discrete values (states) mix small order dependencies certain states higher order dependencies states. instance, binary time series, probability observing 1 time t constant whatever older past states last one (time t − 1) 1, depend states time t − 3 t − 2 state 0 time t − 1. collection past states determines completely transition probabilities context VLMC. Read vignette(\"context-trees\") details contexts context tree, see vignette(\"variable-length-markov-chains\") detailed introduction VLMC. VLMC covariates (COVLMC) extension VLMC transition probabilities (probabilities next state given past) can influenced past values covariates (addition past values time series ). context associated logistic model maps (past values ) covariates transition probabilities.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"fitting-a-vlmc","dir":"","previous_headings":"Usage","what":"Fitting a VLMC","title":"Variable Length Markov Chains with Covariates","text":"package loaded standard way. main function VLMC vlmc() can called time series represented numerical vector factor, instance. default parameters vlmc() tend produce overly complex VLMC order avoid missing potential structure time series. example , expect optimal VLMC constant distribution sample independent uniformly distributed (temporal structure). default parameters give overly complex model, illustrated text based representation representation uses simple ASCII art display contexts VLMC organized tree (see vignette(\"context-trees\") detailed introduction): root * corresponds empty context; one can read contexts following branches (represented 2 dashes --) ends (leaves): instance (1,0,1,0,0,0) one contexts tree. context (1,0,1,0,0,0) associated transition probabilities (1,0). means one observes context time series, always followed 0. Notice contexts traditionally written recent value oldest one. Thus, context (1,0,1,0,0,0) corresponds sub time series (0,0,0,1,0,1).","code":"library(mixvlmc) ## we use ggplot2 for graphics but this is not a dependency of the package library(ggplot2) set.seed(0) x <- sample(c(0L, 1L), 200, replace = TRUE) model <- vlmc(x) model #> VLMC context tree on 0, 1  #>  cutoff: 1.921 (quantile: 0.05) #>  Number of contexts: 11  #>  Maximum context length: 6 draw(model) #> * (0.505, 0.495) #> '-- 1 (0.4848, 0.5152) #>     +-- 0 (0.5319, 0.4681) #>     |   '-- 1 (0.5, 0.5) #>     |       '-- 0 (0.4444, 0.5556) #>     |           '-- 0 (0.4286, 0.5714) #>     |               +-- 0 (1, 0) #>     |               '-- 1 (0, 1) #>     '-- 1 (0.4314, 0.5686) #>         '-- 0 (0.2727, 0.7273) #>             '-- 0 (0.3846, 0.6154) #>                 '-- 0 (0.5, 0.5) #>                     +-- 0 (0, 1) #>                     '-- 1 (1, 0)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"bic-based-model-selection","dir":"","previous_headings":"Usage > Fitting a VLMC","what":"BIC based model selection","title":"Variable Length Markov Chains with Covariates","text":"VLMC obviously overfitting time series, illustrated 0/1 transition probabilities. classical way select good model minimize BIC. mixvlmc can done easily using using ‘tune_vlmc()’ fits first complex VLMC prunes (using combination cutoff() prune()), follows (see vignette(\"variable-length-markov-chains\") details): expected, end constant model. time series actual temporal patterns, optimal model complex. basic illustrative example, let us consider sunspot.year time series turn binary one, high activity associated number sun spots larger median number. adjust automatically optimal VLMC follows: results pruning process can represented graphically:  plot shows simpler models simple BIC increases pruning becomes strong enough. best model remains rather complex (expected based periodicity Solar cycle):","code":"best_model_tune <- tune_vlmc(x) best_model <- as_vlmc(best_model_tune) draw(best_model) #> * (0.505, 0.495) sun_activity <- as.factor(ifelse(sunspot.year >= median(sunspot.year), \"high\", \"low\")) sun_model_tune <- tune_vlmc(sun_activity) sun_model_tune #> VLMC context tree on high, low  #>  cutoff: 2.306 (quantile: 0.0317468917204769) #>  Number of contexts: 9  #>  Maximum context length: 5  #>  Selected by BIC (248.5057) ggplot(sun_model_tune$results, aes(x = alpha, y = BIC)) +   geom_line() +   geom_point() best_sun_model <- as_vlmc(sun_model_tune) draw(best_sun_model) #> * (0.5052, 0.4948) #> +-- high (0.8207, 0.1793) #> |   +-- high (0.7899, 0.2101) #> |   |   +-- high (0.7447, 0.2553) #> |   |   |   +-- high (0.6571, 0.3429) #> |   |   |   |   '-- low (0.9167, 0.08333) #> |   |   |   '-- low (1, 0) #> |   |   '-- low (0.96, 0.04) #> |   '-- low (0.9615, 0.03846) #> '-- low (0.1888, 0.8112) #>     +-- high (0, 1) #>     '-- low (0.2328, 0.7672) #>         +-- high (0, 1) #>         '-- low (0.3034, 0.6966) #>             '-- high (0.07692, 0.9231)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"fitting-a-vlmc-with-covariates","dir":"","previous_headings":"Usage","what":"Fitting a VLMC with covariates","title":"Variable Length Markov Chains with Covariates","text":"illustrate use covariates, use power consumption data set included package (see vignette(\"covlmc\") details). consider week electricity usage follows:  time series displays typical patterns electricity usage: low active power night (typically 0.4 kW); standard use 0.4 2 kW; peak use 2 kW. build discrete time series (somewhat arbitrary) thresholds: best VLMC model quite simple. almost standard order one Markov chain, order 2 context used active power typical. pointed , low active power tend correspond night phase. can include information introducing day covariate follows: COVLMC estimated using covlmc function: model appears bit complex. get adapted model, use BIC based model selection follows: VLMC case, optimal model remains rather simple: high context use covariate equivalent vlmc context; low context interesting: switch high context (hence single row parameters) uses covariate. expected, probability switching low typical larger day; typical context described complex way case vlmc transition probabilities depend previous state.","code":"pc_week_5 <- powerconsumption[powerconsumption$week == 5, ] elec <- pc_week_5$active_power ggplot(pc_week_5, aes(x = date_time, y = active_power)) +   geom_line() +   xlab(\"Date\") +   ylab(\"Activer power (kW)\") elec_dts <- cut(elec, breaks = c(0, 0.4, 2, 8), labels = c(\"low\", \"typical\", \"high\")) elec_vlmc_tune <- tune_vlmc(elec_dts) best_elec_vlmc <- as_vlmc(elec_vlmc_tune) draw(best_elec_vlmc) #> * (0.1667, 0.5496, 0.2837) #> +-- low (0.7665, 0.2335, 0) #> '-- typical (0.0704, 0.8466, 0.08303) #> |   '-- low (0.3846, 0.5385, 0.07692) #> '-- high (0.003497, 0.1573, 0.8392) elec_cov <- data.frame(day = (pc_week_5$hour >= 7 & pc_week_5$hour <= 17)) elec_covlmc <- covlmc(elec_dts, elec_cov, min_size = 2, alpha = 0.5) draw(elec_covlmc, time_sep = \" | \", model = \"full\", p_value = FALSE) #> * #> +-- low ([ (I)    | day_1TRUE #> |          -1.558 | 1.006     ]) #> '-- typical #> |   +-- low ([ (I)    | day_1TRUE | day_2TRUE #> |   |          0.3567 | -27.81    | 27.81     #> |   |          -1.253 | -14.39    | 13.69     ]) #> |   '-- typical ([ (I)    | day_1TRUE #> |   |              2.666  | 0.566     #> |   |              0.2683 | 0.2426    ]) #> |   '-- high ([ (I)    | day_1TRUE #> |               2.015  | 16.18     #> |               0.6931 | 16.61     ]) #> '-- high ([ (I)   | day_1TRUE #>             17.41 | -14.23    #>             19.38 | -14.88    ]) elec_covlmc_tune <- tune_covlmc(elec_dts, elec_cov) best_elec_covlmc <- as_covlmc(elec_covlmc_tune) draw(best_elec_covlmc, model = \"full\", time_sep = \" | \", p_value = FALSE) #> * #> +-- low ([ (I)    | day_1TRUE #> |          -1.558 | 1.006     ]) #> '-- typical #> |   +-- low ([ (I)    #> |   |          0.3365 #> |   |          -1.609 ]) #> |   '-- typical ([ (I)    #> |   |              2.937  #> |   |              0.3747 ]) #> |   '-- high ([ (I)   #> |               2.773 #> |               1.705 ]) #> '-- high ([ (I)   #>             3.807 #>             5.481 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/index.html","id":"sampling","dir":"","previous_headings":"Usage","what":"Sampling","title":"Variable Length Markov Chains with Covariates","text":"VLMC models can also used sample new time series VMLC bootstrap proposed Bühlmann Wyner. instance, can estimate longest time period spent high active power regime. “predictive” setting, AIC may adapted select best model. Notice quantities can computed directly model VLMC case, using classical results Markov Chains. See vignette(\"sampling\") details sampling. first select two models based AIC. sample 100 new time series model, using simulate() function follows: statistics can computed time series. instance, look longest time period spent high active power regime. average longest time spent high consecutively VLMC: 243.6 minutes standard error 6.7337834; VLMC covariate: 286.2 minutes standard error 8.9157448; 410 minutes observed time series. following figure shows distributions times obtained models well observed value. VLMC model covariate able generate longer sequences high active power state bare VLMC model consequence sensitivity day/night schedule.  VLMC covariate can used investigate effects changes covariates. instance, day time longer, expect high power usage less frequent. instance, simulate one week day time 6:00 20:00 follows. expected distribution longest time spend consecutively high power usage shifted lower values day length increased.","code":"best_elec_vlmc_aic <- as_vlmc(tune_vlmc(elec_dts, criterion = \"AIC\")) best_elec_covlmc_aic <- as_covlmc(tune_covlmc(elec_dts, elec_cov, criterion = \"AIC\")) set.seed(0) vlmc_simul <- vector(mode = \"list\", 100) for (k in seq_along(vlmc_simul)) {   vlmc_simul[[k]] <- simulate(best_elec_vlmc_aic, nsim = length(elec_dts), init = elec_dts[1:2]) } set.seed(0) covlmc_simul <- vector(mode = \"list\", 100) for (k in seq_along(covlmc_simul)) {   covlmc_simul[[k]] <- simulate(best_elec_covlmc_aic, nsim = length(elec_dts), covariate = elec_cov, init = elec_dts[1:2]) } longuest_high <- function(x) {   high_length <- rle(x == \"high\")   10 * max(high_length$lengths[high_length$values]) } lh_vlmc <- sapply(vlmc_simul, longuest_high) lh_covlmc <- sapply(covlmc_simul, longuest_high) lh <- data.frame(   time = c(lh_vlmc, lh_covlmc),   model = c(rep(\"VLMC\", length(lh_vlmc)), rep(\"COVLMC\", length(lh_covlmc))) ) ggplot(lh, aes(x = time, color = model)) +   geom_density() +   geom_rug(alpha = 0.5) +   geom_vline(xintercept = longuest_high(elec_dts), color = 3) elec_cov_long_days <- data.frame(day = (pc_week_5$hour >= 6 & pc_week_5$hour <= 20)) set.seed(0) covlmc_simul_ld <- vector(mode = \"list\", 100) for (k in seq_along(covlmc_simul_ld)) {   covlmc_simul_ld[[k]] <- simulate(best_elec_covlmc_aic, nsim = length(elec_dts), covariate = elec_cov_long_days, init = elec_dts[1:2]) } lh_covlmc_ld <- sapply(covlmc_simul_ld, longuest_high) day_time_effect <- data.frame(   time = c(lh_covlmc, lh_covlmc_ld),   `day length` = c(rep(\"Short days\", length(lh_covlmc)), rep(\"Long days\", length(lh_covlmc_ld))),   check.names = FALSE ) ggplot(day_time_effect, aes(x = time, color = `day length`)) +   geom_density() +   geom_rug(alpha = 0.5)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","title":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","text":"generic function converts object covlmc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","text":"","code":"as_covlmc(x, ...)  # S3 method for tune_covlmc as_covlmc(x, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","text":"x object convert covlmc. ... additional arguments conversion functions.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","text":"covlmc","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an object to a Variable Length Markov Chain with covariates (coVLMC) — as_covlmc","text":"","code":"## conversion from the results of tune_covlmc pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) dts_best_model_tune <- tune_covlmc(dts, dts_cov) dts_best_model <- as_covlmc(dts_best_model_tune) draw(dts_best_model) #> * (collapsing: 1.328e-190) #> +-- (0,1.34] (0.1957 [ -2.533 ]) #> '-- (1.34,7.54] (0.8175 [ 2.535 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"generic function converts object vlmc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"","code":"as_vlmc(x, ...)  # S3 method for ctx_tree as_vlmc(x, alpha, cutoff, ...)  # S3 method for tune_vlmc as_vlmc(x, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"x object convert vlmc. ... additional arguments conversion functions. alpha cut parameter applied conversion, quantile scale (specified) cutoff cut parameter applied conversion, native scale (specified)","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"vlmc","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"function converts context tree VLMC. alpha cutoff specified, used reduce complexity tree direct call vlmc() (prune()).","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/as_vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an object to a Variable Length Markov Chain (VLMC) — as_vlmc","text":"","code":"## conversion from a context tree dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 3) draw(dts_ctree) #> * #> +-- 0 #> |   +-- 0 #> |   |   '-- 1 #> |   '-- 1 #> |       +-- 0 #> |       '-- 1 #> '-- 1 #>     +-- 0 #>     |   +-- 0 #>     |   '-- 1 #>     '-- 1 #>         +-- 0 #>         '-- 1 dts_vlmc <- as_vlmc(dts_ctree) class(dts_vlmc) #> [1] \"vlmc\"     \"ctx_tree\" draw(dts_vlmc) #> * (0.5, 0.5) #> +-- 0 (0.25, 0.75) #> |   +-- 0 (0, 1) #> |   |   '-- 1 (0, 1) #> |   '-- 1 (0.5, 0.5) #> |       +-- 0 (0, 1) #> |       '-- 1 (1, 0) #> '-- 1 (0.6, 0.4) #>     +-- 0 (0.6667, 0.3333) #>     |   +-- 0 (1, 0) #>     |   '-- 1 (1, 0) #>     '-- 1 (0.5, 0.5) #>         +-- 0 (0, 1) #>         '-- 1 (1, 0) ## conversion from the result of tune_vlmc dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) tune_result <- tune_vlmc(dts) tune_result #> VLMC context tree on A, B, C  #>  cutoff: 4.009 (quantile: 0.01815) #>  Number of contexts: 1  #>  Maximum context length: 0  #>  Selected by BIC (225.6048) with likelihood function \"truncated\" (-108.1972) dts_best_vlmc <- as_vlmc(tune_result) draw(dts_best_vlmc) #> * (0.42, 0.28, 0.3)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Contexts number of a VLMC with covariates — context_number.covlmc","title":"Contexts number of a VLMC with covariates — context_number.covlmc","text":"function returns total number contexts VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contexts number of a VLMC with covariates — context_number.covlmc","text":"","code":"# S3 method for covlmc context_number(ct)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contexts number of a VLMC with covariates — context_number.covlmc","text":"ct fitted covlmc model.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contexts number of a VLMC with covariates — context_number.covlmc","text":"number contexts present VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contexts number of a VLMC with covariates — context_number.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) m_nocovariate <- vlmc(dts) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 10) # should be 4 context_number(m_cov) #> [1] 3"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of contexts of a context tree — context_number","title":"Number of contexts of a context tree — context_number","text":"function returns number distinct contexts context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of contexts of a context tree — context_number","text":"","code":"context_number(ct)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of contexts of a context tree — context_number","text":"ct context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of contexts of a context tree — context_number","text":"number contexts tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/context_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of contexts of a context tree — context_number","text":"","code":"dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 3) # should be 8 context_number(dts_ctree) #> [1] 8"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Contexts of a VLMC with covariates — contexts.covlmc","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"function returns different contexts present VLMC covariates, possibly associated data.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"","code":"# S3 method for covlmc contexts(   ct,   type = c(\"auto\", \"list\", \"data.frame\"),   reverse = TRUE,   frequency = NULL,   positions = FALSE,   counts = c(\"desc\", \"local\"),   model = NULL,   hsize = FALSE,   metrics = FALSE,   merging = FALSE,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"ct fitted covlmc model. type result type (see details). reverse logical (defaults TRUE). See details. frequency specifies counts included result data.frame. default value NULL include anything. \"total\" gives number occurrences context original sequence. \"detailed\" includes addition break occurrences possible states. positions logical (defaults FALSE). Specify whether positions context time series used build context tree reported positions column result data frame. availability positions depends way context tree built. See details definition position. counts specifies counts reported frequency computed. default value \"desc\" includes counts specific context () counts descendants context tree. counts = \"local\" counts include number times context appears without last part longer context. model specifies whether include model associated context. default result model=NULL include model. Setting model \"coef\" adds coefficients models coef column, \"full\" include models (R objects) model column. hsize TRUE, adds hsize column result data frame gives context size history covariates used model. metrics TRUE, adds predictive metrics context (see metrics() definition predictive metrics). merging TRUE, adds merged column result data frame. normal context, value merged FALSE. Contexts share model TRUE merged value. ... additional arguments contexts function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"list contexts represented tree data.frame content.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"result list contexts type=\"auto\" (type=\"list\"), details asked via specific parameters (e.g. setting model non NULL value). results obtained type=\"data.frame\" (type=\"auto\"). See contexts.ctx_tree() details frequency parameter. model non NULL, resulting data.frame contains models associated context (either full R model coefficients).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"positions","dir":"Reference","previous_headings":"","what":"Positions","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"position context ctx time series x index value t context ends x[t]. Thus x[t+1] context. instance x=c(0, 0, 1, 1) ctx=c(0, 1) (standard state order), position ctx x 3.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"state-order-in-a-context","dir":"Reference","previous_headings":"","what":"State order in a context","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"Notice contexts given default \"reverse\" order used VLMC papers: older values right. instance, context c(0, 1) reported sequence 1, 0 appeared time series used build context tree. Set reverse FALSE reverse convention.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contexts of a VLMC with covariates — contexts.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(0, median(pc$active_power), max(pc$active_power)) dts <- cut(pc$active_power, breaks = breaks) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) contexts(m_cov, model = \"coef\") #>        context         coef #> 1 (0,1.34].... -2.81304.... #> 2 (0,1.34].... -19.5660.... #> 3 (0,1.34].... -1.85629.... #> 4  (1.34,7.54] 2.535411.... contexts(m_cov, model = \"full\") #>        context        model #> 1 (0,1.34].... c(`(Inte.... #> 2 (0,1.34].... c(`(Inte.... #> 3 (0,1.34].... c(`(Inte.... #> 4  (1.34,7.54] c(`(Inte...."},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Contexts of a context tree — contexts.ctx_tree","title":"Contexts of a context tree — contexts.ctx_tree","text":"function extracts context tree description contexts.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contexts of a context tree — contexts.ctx_tree","text":"","code":"# S3 method for ctx_tree contexts(   ct,   type = c(\"auto\", \"list\", \"data.frame\"),   reverse = TRUE,   frequency = NULL,   positions = FALSE,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contexts of a context tree — contexts.ctx_tree","text":"ct context tree. type result type (see details). reverse logical (defaults TRUE). See details. frequency specifies counts included result data.frame. default value NULL include anything. \"total\" gives number occurrences context original sequence. \"detailed\" includes addition break occurrences possible states. positions logical (defaults FALSE). Specify whether positions context time series used build context tree reported positions column result data frame. availability positions depends way context tree built. See details definition position. ... additional arguments contexts function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contexts of a context tree — contexts.ctx_tree","text":"list contexts represented tree data.frame content.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contexts of a context tree — contexts.ctx_tree","text":"default result type=\"auto\" (type=\"list\") frequency=NULL list contexts. results obtained type=\"data.frame\" (type=\"auto\"). case resulting data.frame context column storing contexts. frequency=\"total\", additional column named freq gives number occurrences context series used build tree. frequency=\"detailed\", one additional column added per state context space. column records number times given context followed corresponding value original series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"positions","dir":"Reference","previous_headings":"","what":"Positions","title":"Contexts of a context tree — contexts.ctx_tree","text":"position context ctx time series x index value t context ends x[t]. Thus x[t+1] context. instance x=c(0, 0, 1, 1) ctx=c(0, 1) (standard state order), position ctx x 3.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"state-order-in-a-context","dir":"Reference","previous_headings":"","what":"State order in a context","title":"Contexts of a context tree — contexts.ctx_tree","text":"Notice contexts given default \"reverse\" order used VLMC papers: older values right. instance, context c(0, 1) reported sequence 1, 0 appeared time series used build context tree. Set reverse FALSE reverse convention.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.ctx_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contexts of a context tree — contexts.ctx_tree","text":"","code":"dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) dts_tree <- ctx_tree(dts, max_depth = 3, min_size = 5) contexts(dts_tree) #> [[1]] #> [1] A A A #> Levels: A B C #>  #> [[2]] #> [1] A A B #> Levels: A B C #>  #> [[3]] #> [1] A A #> Levels: A B C #>  #> [[4]] #> [1] A B C #> Levels: A B C #>  #> [[5]] #> [1] A B #> Levels: A B C #>  #> [[6]] #> [1] A C #> Levels: A B C #>  #> [[7]] #> [1] B A A #> Levels: A B C #>  #> [[8]] #> [1] B A #> Levels: A B C #>  #> [[9]] #> [1] B B #> Levels: A B C #>  #> [[10]] #> [1] B C A #> Levels: A B C #>  #> [[11]] #> [1] B C #> Levels: A B C #>  #> [[12]] #> [1] C A A #> Levels: A B C #>  #> [[13]] #> [1] C A B #> Levels: A B C #>  #> [[14]] #> [1] C A #> Levels: A B C #>  #> [[15]] #> [1] C B #> Levels: A B C #>  #> [[16]] #> [1] C C A #> Levels: A B C #>  #> [[17]] #> [1] C C #> Levels: A B C #>  contexts(dts_tree, frequency = \"total\") #>    context freq #> 1  A, A, A    5 #> 2  A, A, B    6 #> 3     A, A   15 #> 4  A, B, C    7 #> 5     A, B   13 #> 6     A, C    8 #> 7  B, A, A    5 #> 8     B, A    8 #> 9     B, B    9 #> 10 B, C, A    5 #> 11    B, C   13 #> 12 C, A, A    5 #> 13 C, A, B    6 #> 14    C, A   13 #> 15    C, B    8 #> 16 C, C, A    5 #> 17    C, C   11 contexts(dts_tree, frequency = \"detailed\") #>    context freq A B C #> 1  A, A, A    5 2 0 3 #> 2  A, A, B    6 2 3 1 #> 3     A, A   15 5 5 5 #> 4  A, B, C    7 3 0 4 #> 5     A, B   13 6 1 6 #> 6     A, C    8 4 2 2 #> 7  B, A, A    5 1 3 1 #> 8     B, A    8 2 4 2 #> 9     B, B    9 3 3 3 #> 10 B, C, A    5 2 1 2 #> 11    B, C   13 7 3 3 #> 12 C, A, A    5 1 3 1 #> 13 C, A, B    6 1 2 3 #> 14    C, A   13 3 5 5 #> 15    C, B    8 2 4 2 #> 16 C, C, A    5 1 2 2 #> 17    C, C   11 3 4 4"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":null,"dir":"Reference","previous_headings":"","what":"Contexts of a context tree — contexts","title":"Contexts of a context tree — contexts","text":"function extracts context tree description contexts.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contexts of a context tree — contexts","text":"","code":"contexts(ct, type = c(\"auto\", \"list\", \"data.frame\"), reverse = TRUE, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contexts of a context tree — contexts","text":"ct context tree. type result type (see details). reverse logical (defaults TRUE). See details. ... additional arguments contexts function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contexts of a context tree — contexts","text":"list contexts represented tree data.frame content.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contexts of a context tree — contexts","text":"default behavior consists returning list contexts contained tree (type=\"auto\" type=\"list\"). type=\"data.frame\", method returns data.frame whose first column, named context, contains contexts. columns contain context specific values depend actual class tree additional parameters. adapted return type chosen type=\"auto\"`.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"state-order-in-a-context","dir":"Reference","previous_headings":"","what":"State order in a context","title":"Contexts of a context tree — contexts","text":"Notice contexts given default \"reverse\" order used VLMC papers: older values right. instance, context c(0, 1) reported sequence 1, 0 appeared time series used build context tree. Set reverse FALSE reverse convention.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contexts of a context tree — contexts","text":"","code":"dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) dts_tree <- ctx_tree(dts, max_depth = 3, min_size = 5) contexts(dts_tree) #> [[1]] #> [1] A A #> Levels: A B C #>  #> [[2]] #> [1] A B C #> Levels: A B C #>  #> [[3]] #> [1] A B #> Levels: A B C #>  #> [[4]] #> [1] A C A #> Levels: A B C #>  #> [[5]] #> [1] A C #> Levels: A B C #>  #> [[6]] #> [1] B A C #> Levels: A B C #>  #> [[7]] #> [1] B A #> Levels: A B C #>  #> [[8]] #> [1] B B #> Levels: A B C #>  #> [[9]] #> [1] B C B #> Levels: A B C #>  #> [[10]] #> [1] B C #> Levels: A B C #>  #> [[11]] #> [1] C A #> Levels: A B C #>  #> [[12]] #> [1] C B A #> Levels: A B C #>  #> [[13]] #> [1] C B #> Levels: A B C #>  #> [[14]] #> [1] C C C #> Levels: A B C #>  #> [[15]] #> [1] C C #> Levels: A B C #>  contexts(dts_tree, \"data.frame\", TRUE) #>    context #> 1     A, A #> 2  A, B, C #> 3     A, B #> 4  A, C, A #> 5     A, C #> 6  B, A, C #> 7     B, A #> 8     B, B #> 9  B, C, B #> 10    B, C #> 11    C, A #> 12 C, B, A #> 13    C, B #> 14 C, C, C #> 15    C, C"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Contexts of a VLMC — contexts.vlmc","title":"Contexts of a VLMC — contexts.vlmc","text":"function extracts contexts fitted VLMC, possibly associated data.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contexts of a VLMC — contexts.vlmc","text":"","code":"# S3 method for vlmc contexts(   ct,   type = c(\"auto\", \"list\", \"data.frame\"),   reverse = TRUE,   frequency = NULL,   positions = FALSE,   counts = c(\"desc\", \"local\"),   cutoff = NULL,   metrics = FALSE,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contexts of a VLMC — contexts.vlmc","text":"ct context tree. type result type (see details). reverse logical (defaults TRUE). See details. frequency specifies counts included result data.frame. default value NULL include anything. \"total\" gives number occurrences context original sequence. \"detailed\" includes addition break occurrences possible states. positions logical (defaults FALSE). Specify whether positions context time series used build context tree reported positions column result data frame. availability positions depends way context tree built. See details definition position. counts specifies counts reported frequency computed. default value \"desc\" includes counts specific context () counts descendants context tree. counts = \"local\" counts include number times context appears without last part longer context. cutoff specifies whether include cut value associated context (see cutoff() prune()). default result cutoff=NULL include values. Setting cutoff quantile adds cut values quantile scale, cutoff=\"native\" adds native scale. returned values directly based log likelihood ratio computed context tree modified ensure pruning (cutoff() called  raw=TRUE). metrics TRUE, adds predictive metrics context (see metrics() definition predictive metrics). ... additional arguments contexts function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contexts of a VLMC — contexts.vlmc","text":"list contexts represented tree data.frame content.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contexts of a VLMC — contexts.vlmc","text":"default result type=\"auto\" (type=\"list\"), frequency=NULL, cutoff=NULL metrics=FALSE list contexts. results obtained type=\"auto\" type=\"data.frame\". See contexts.ctx_tree() details frequency parameter. cutoff non NULL, resulting data.frame contains cutoff column cut values, either quantile native scale. See cutoff() prune() definitions cut values two scales.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"cut-off-values","dir":"Reference","previous_headings":"","what":"Cut off values","title":"Contexts of a VLMC — contexts.vlmc","text":"cut values reported contexts.vlmc can different ones reported cutoff() three reasons: cutoff() reports useful cut values, .e., cut values induce simplification VLMC used prune(). exclude cut values associated simple contexts smaller ones descendants context tree. values reported context.vlmc. context.vlmc reports cut values actual contexts, cutoff() reports cut values nodes context tree. values modified induce pruning, contrarily default behaviour cutoff()","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"positions","dir":"Reference","previous_headings":"","what":"Positions","title":"Contexts of a VLMC — contexts.vlmc","text":"position context ctx time series x index value t context ends x[t]. Thus x[t+1] context. instance x=c(0, 0, 1, 1) ctx=c(0, 1) (standard state order), position ctx x 3.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"state-order-in-a-context","dir":"Reference","previous_headings":"","what":"State order in a context","title":"Contexts of a VLMC — contexts.vlmc","text":"Notice contexts given default \"reverse\" order used VLMC papers: older values right. instance, context c(0, 1) reported sequence 1, 0 appeared time series used build context tree. Set reverse FALSE reverse convention.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/contexts.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contexts of a VLMC — contexts.vlmc","text":"","code":"dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) model <- vlmc(dts, alpha = 0.5) contexts(model) #> [[1]] #> [1] A A A #> Levels: A B C #>  #> [[2]] #> [1] A A C A C #> Levels: A B C #>  #> [[3]] #> [1] A A C A #> Levels: A B C #>  #> [[4]] #> [1] A A C #> Levels: A B C #>  #> [[5]] #> [1] A A #> Levels: A B C #>  #> [[6]] #> [1] A B B A B #> Levels: A B C #>  #> [[7]] #> [1] A B B A #> Levels: A B C #>  #> [[8]] #> [1] A B B B #> Levels: A B C #>  #> [[9]] #> [1] A B B #> Levels: A B C #>  #> [[10]] #> [1] A B #> Levels: A B C #>  #> [[11]] #> [1] A C A C #> Levels: A B C #>  #> [[12]] #> [1] A C A #> Levels: A B C #>  #> [[13]] #> [1] A C B #> Levels: A B C #>  #> [[14]] #> [1] A C C #> Levels: A B C #>  #> [[15]] #> [1] B A A #> Levels: A B C #>  #> [[16]] #> [1] B A B B #> Levels: A B C #>  #> [[17]] #> [1] B A B #> Levels: A B C #>  #> [[18]] #> [1] B A C A #> Levels: A B C #>  #> [[19]] #> [1] B A C B B C #> Levels: A B C #>  #> [[20]] #> [1] B A C B B #> Levels: A B C #>  #> [[21]] #> [1] B A C B #> Levels: A B C #>  #> [[22]] #> [1] B A C #> Levels: A B C #>  #> [[23]] #> [1] B B A B #> Levels: A B C #>  #> [[24]] #> [1] B B A C #> Levels: A B C #>  #> [[25]] #> [1] B B A #> Levels: A B C #>  #> [[26]] #> [1] B B B B #> Levels: A B C #>  #> [[27]] #> [1] B B B #> Levels: A B C #>  #> [[28]] #> [1] B B #> Levels: A B C #>  #> [[29]] #> [1] B C B #> Levels: A B C #>  #> [[30]] #> [1] B C C A #> Levels: A B C #>  #> [[31]] #> [1] B C C C #> Levels: A B C #>  #> [[32]] #> [1] B C C #> Levels: A B C #>  #> [[33]] #> [1] B C #> Levels: A B C #>  #> [[34]] #> [1] C A A #> Levels: A B C #>  #> [[35]] #> [1] C A B A #> Levels: A B C #>  #> [[36]] #> [1] C A B B #> Levels: A B C #>  #> [[37]] #> [1] C A B #> Levels: A B C #>  #> [[38]] #> [1] C A C #> Levels: A B C #>  #> [[39]] #> [1] C B A #> Levels: A B C #>  #> [[40]] #> [1] C B B #> Levels: A B C #>  #> [[41]] #> [1] C B C #> Levels: A B C #>  #> [[42]] #> [1] C C A #> Levels: A B C #>  #> [[43]] #> [1] C C B #> Levels: A B C #>  #> [[44]] #> [1] C C C #> Levels: A B C #>  contexts(model, frequency = \"total\") #>         context freq #> 1       A, A, A    2 #> 2  A, A, C,....    2 #> 3    A, A, C, A    3 #> 4       A, A, C    3 #> 5          A, A    6 #> 6  A, B, B,....    2 #> 7    A, B, B, A    3 #> 8    A, B, B, B    3 #> 9       A, B, B    7 #> 10         A, B   11 #> 11   A, C, A, C    2 #> 12      A, C, A    5 #> 13      A, C, B    5 #> 14      A, C, C    2 #> 15      B, A, A    2 #> 16   B, A, B, B    4 #> 17      B, A, B    5 #> 18   B, A, C, A    2 #> 19 B, A, C,....    2 #> 20 B, A, C,....    3 #> 21   B, A, C, B    3 #> 22      B, A, C    6 #> 23   B, B, A, B    4 #> 24   B, B, A, C    2 #> 25      B, B, A    7 #> 26   B, B, B, B    2 #> 27      B, B, B    6 #> 28         B, B   18 #> 29      B, C, B    2 #> 30   B, C, C, A    2 #> 31   B, C, C, C    2 #> 32      B, C, C    4 #> 33         B, C    8 #> 34      C, A, A    2 #> 35   C, A, B, A    2 #> 36   C, A, B, B    2 #> 37      C, A, B    5 #> 38      C, A, C    3 #> 39      C, B, A    3 #> 40      C, B, B    5 #> 41      C, B, C    2 #> 42      C, C, A    2 #> 43      C, C, B    3 #> 44      C, C, C    4 contexts(model, cutoff = \"quantile\") #>         context    cutoff #> 1       A, A, A 0.1111111 #> 2  A, A, C,.... 0.4444444 #> 3    A, A, C, A 1.0000000 #> 4       A, A, C 0.2500000 #> 5          A, A 0.7456392 #> 6  A, B, B,.... 0.4444444 #> 7    A, B, B, A 0.0787172 #> 8    A, B, B, B 0.1865889 #> 9       A, B, B 0.6448483 #> 10         A, B 0.5334694 #> 11   A, C, A, C 0.3600000 #> 12      A, C, A 0.1130281 #> 13      A, C, B 0.2260561 #> 14      A, C, C 0.5000000 #> 15      B, A, A 0.4970414 #> 16   B, A, B, B 0.4096000 #> 17      B, A, B 0.2368136 #> 18   B, A, C, A 0.4444444 #> 19 B, A, C,.... 0.4444444 #> 20 B, A, C,.... 1.0000000 #> 21   B, A, C, B 0.2500000 #> 22      B, A, C 0.5994439 #> 23   B, B, A, B 0.2399000 #> 24   B, B, A, C 0.4897959 #> 25      B, B, A 0.9612395 #> 26   B, B, B, B 0.3333333 #> 27      B, B, B 0.7841792 #> 28         B, B 0.4985195 #> 29      B, C, B 0.3906250 #> 30   B, C, C, A 0.5000000 #> 31   B, C, C, C 0.5000000 #> 32      B, C, C 0.7812500 #> 33         B, C 0.5212526 #> 34      C, A, A 0.4800000 #> 35   C, A, B, A 0.3600000 #> 36   C, A, B, B 0.1600000 #> 37      C, A, B 1.0000000 #> 38      C, A, C 0.4860000 #> 39      C, B, A 0.1215000 #> 40      C, B, B 0.2288818 #> 41      C, B, C 0.4000000 #> 42      C, C, A 0.1600000 #> 43      C, C, B 0.2160000 #> 44      C, C, C 0.4096000"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"function fits  Variable Length Markov Chain covariates (coVLMC) discrete time series coupled time series covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"","code":"covlmc(   x,   covariate,   alpha = 0.05,   min_size = 5L,   max_depth = 100L,   keep_data = TRUE,   control = covlmc_control(...),   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"x discrete time series; can numeric, character, factor logical. covariate data frame covariates. alpha number (0,1) (default: 0.05) cut value pruning phase (quantile scale). min_size number >= 1 (default: 5). Tune minimum number observations context growing phase context tree (see details). max_depth integer >= 1 (default: 100). Longest context considered growing phase context tree. keep_data logical (defaults TRUE). TRUE, original data stored resulting object enable post pruning (see prune.covlmc()). control list control parameters, see covlmc_control(). ... arguments passed covlmc_control().","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"fitted covlmc model.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"model built using algorithm described Zanin Zambom et al. vlmc() approach, algorithm builds first context tree (see ctx_tree()). min_size parameter used compute actual number observations per context growing phase tree. computed min_size*(1+ncol(covariate)*d)*(s-1) d length context (.k.. depth tree) s number states. corresponds ensuring min_size observations per parameter logistic regression estimation phase. logistic models adjusted leaves tree: goal logistic model estimate conditional distribution next state times series given context (recent past time series) delayed versions covariates. pruning strategy used simplified models (mainly reduce time window associated covariates) tree . Parameters specified control used fine tune behaviour algorithm.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"logistic-models","dir":"Reference","previous_headings":"","what":"Logistic models","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"default, covlmc uses two different computing engines logistic models: time series two states, covlmc uses stats::glm() binomial link (stats::binomial()); time series least three states, covlmc use VGAM::vglm() multinomial link (VGAM::multinomial()). engines able detect degenerate cases lead robust results using nnet::multinom(). nevertheless possible replace stats::glm() VGAM::vglm() nnet::multinom() setting global option mixvlmc.predictive \"multinom\" (default value \"glm\"). Notice results comparable, guarantee identical.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"Bühlmann, P. Wyner, . J. (1999), \"Variable length Markov chains.\" Ann. Statist. 27 (2) 480-513 doi:10.1214/aos/1018031204 Zanin Zambom, ., Kim, S. Lopes Garcia, N. (2022), \"Variable length Markov chain exogenous covariates.\" J. Time Ser. Anal., 43 (2) 312-328 doi:10.1111/jtsa.12615","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Variable Length Markov Chain with Covariates (coVLMC) — covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(1 / 3, 2 / 3, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 15) draw(m_cov) #> * (merging ((0.556,1.78] and (1.78,7.54]): 1.347e-96) #> +-- (0,0.556] (0.001385 [ -2.885 1.237 #> |                         -4.185 -15.4 ]) #> '-- (0.556,1.78] (0.8622 [ 2.046  #> |                          0.1372 ]) #> '-- (1.78,7.54] (0.227 [ 3.714 #>                          5.684 ]) withr::with_options(   list(mixvlmc.predictive = \"multinom\"),   m_cov_nnet <- covlmc(dts, dts_cov, min_size = 15) ) draw(m_cov_nnet) #> * (merging ((0.556,1.78] and (1.78,7.54]): 1.347e-96) #> +-- (0,0.556] (0.001386 [ -2.885 1.237  #> |                         -4.185 -7.944 ]) #> '-- (0.556,1.78] (0.8622 [ 2.046  #> |                          0.1372 ]) #> '-- (1.78,7.54] (0.2274 [ 3.714 #>                           5.684 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Control for coVLMC fitting — covlmc_control","title":"Control for coVLMC fitting — covlmc_control","text":"function creates list parameters used fine tune coVLMC fitting algorithm.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control for coVLMC fitting — covlmc_control","text":"","code":"covlmc_control(pseudo_obs = 1)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control for coVLMC fitting — covlmc_control","text":"pseudo_obs number fake observations state add observed ones.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control for coVLMC fitting — covlmc_control","text":"list.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control for coVLMC fitting — covlmc_control","text":"pseudo_obs used regularize probability estimations context observed followed always state. Transition probabilities computed adding pseudo_obs pseudo observations states (including observed one). corresponds Bayesian posterior mean estimation Dirichlet prior.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/covlmc_control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control for coVLMC fitting — covlmc_control","text":"","code":"dts <- rep(c(0, 1), 100) dts_cov <- data.frame(y = rep(0, length(dts))) default_model <- covlmc(dts, dts_cov) contexts(default_model, type = \"data.frame\", model = \"coef\")$coef #> [[1]] #> [1] 4.615121 #>  #> [[2]] #> [1] -4.60517 #>  control <- covlmc_control(pseudo_obs = 10) model <- covlmc(dts, dts_cov, control = control) contexts(model, type = \"data.frame\", model = \"coef\")$coef #> [[1]] #> [1] 2.397895 #>  #> [[2]] #> [1] -2.388763 #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a context tree for a discrete time series — ctx_tree","title":"Build a context tree for a discrete time series — ctx_tree","text":"function builds context tree time series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a context tree for a discrete time series — ctx_tree","text":"","code":"ctx_tree(x, min_size = 2L, max_depth = 100L, keep_position = TRUE)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a context tree for a discrete time series — ctx_tree","text":"x discrete time series; can numeric, character, factor logical. min_size integer >= 1 (default: 2). Minimum number observations context included tree. max_depth integer >= 1 (default: 100). Maximum length context included tree. keep_position logical (default: TRUE). context tree keep position contexts.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a context tree for a discrete time series — ctx_tree","text":"context tree (class ctx_tree).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build a context tree for a discrete time series — ctx_tree","text":"tree represents sequences symbols/states length smaller max_depth appear least min_size times time series stores frequencies states follow context. Optionally, positions contexts time series can stored tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/ctx_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a context tree for a discrete time series — ctx_tree","text":"","code":"dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) ## get all contexts of length 2 dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 2) draw(dts_ctree) #> * #> +-- 0 #> |   +-- 0 #> |   '-- 1 #> '-- 1 #>     +-- 0 #>     '-- 1"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"function returns cutoff values induce pruning context tree VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"","code":"# S3 method for covlmc cutoff(   vlmc,   mode = c(\"quantile\", \"native\"),   raw = FALSE,   tolerance = .Machine$double.eps^0.5,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"vlmc fitted covlmc model. mode specify whether results \"native\" likelihood ratio values expressed \"quantile\" scale chi-squared distribution. covlmc, quantile scale supported. raw specify whether returned values limit values computed model modified values guarantee pruning (see details) tolerance specify minimum separation two consecutive values cut native mode (transformation). See details. ... additional arguments cutoff function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"vector cut values, NULL none can computed","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"Notice list cutoff values returned function complete one computed VLMC without covariates. Indeed, pruning coVLMC tree creates new pruning opportunities evaluated construction initial model, pruning opportunities computed construction VLMC context tree. Nevertheless, largest value returned function guaranteed produce least pruned tree consistent reference one. large COVLMC, cut values can almost identical, difference order machine epsilon value. tolerance parameter used keep values different enough. done quantile scale, transformations implemented raw FALSE. Notice loglikelihood scale directly useful coVLMC differences model sizes constant pruning process. consequence, \"native\" scale supported function. Setting raw TRUE removes small perturbation subtracted log-likelihood ratio values computed coVLMC (quantile scale).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cutoff values for pruning the context tree of a VLMC with covariates — cutoff.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) m_nocovariate <- vlmc(dts) draw(m_nocovariate) #> * (0.5, 0.5) #> +-- (0,1.34] (0.9264, 0.07356) #> '-- (1.34,7.54] (0.07341, 0.9266) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) draw(m_cov) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] (0.02329 [ -2.813 2.178 -4.449 2.418 ]) #> |   |   '-- (1.34,7.54] (0.01834 [ -19.57 18.39 ]) #> |   '-- (1.34,7.54] (0.6763 [ -1.856 ]) #> '-- (1.34,7.54] (0.8175 [ 2.535 ]) cutoff(m_cov) #> [1] 0.02328831 0.01834317"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut off values for pruning the context tree of a VLMC — cutoff","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"function returns collection cut values guaranteed induce valid pruned trees context tree VLMC. Pruning implemented prune() function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"","code":"cutoff(   vlmc,   mode = c(\"quantile\", \"native\"),   raw = FALSE,   tolerance = .Machine$double.eps^0.5,   ... )  # S3 method for vlmc cutoff(   vlmc,   mode = c(\"quantile\", \"native\"),   raw = FALSE,   tolerance = .Machine$double.eps^0.5,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"vlmc fitted VLMC model. mode specify whether results \"native\" log likelihood ratio values expressed \"quantile\" scale chi-squared distribution (defaults \"quantile\"). raw specify whether returned values limit values computed model modified values guarantee pruning (see details) tolerance specify minimum separation two consecutive values cut native mode (transformation). See details. ... additional arguments cutoff function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"vector cut values.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"default, function returns values can used directly induce pruning context tree. done computing log likelihood ratios used context algorithm reference VLMC keeping relevant ones. function selects intermediate values guaranteed generate via pruning VLMC models generated using larger values cutoff parameter used build reference model (smaller values alpha parameter \"quantile\" scale). Setting raw parameter TRUE removes operation values asks function return relevant log likelihood ratios. large VLMC, log likelihood ratios can almost identical, difference order machine epsilon value. tolerance parameter used keep values different enough. done native scale, transformations implemented raw FALSE. automated model selection provided tune_vlmc(), direct use cutoff reserved advanced exploration set trees can obtained complex one, e.g. implement model selection techniques provided tune_vlmc().","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/cutoff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut off values for pruning the context tree of a VLMC — cutoff","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))) model <- vlmc(dts) draw(model) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> |   '-- (0,0.458] (0.809, 0.1809, 0.005025, 0.005025) #> |       '-- (0,0.458] (0.8188, 0.1688, 0.00625, 0.00625) #> |           '-- (0,0.458] (0.8462, 0.1385, 0.007692, 0.007692) #> |               '-- (0.458,1.34] (0.55, 0.4, 0, 0.05) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   +-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> |   |   '-- (0,0.458] (0.3611, 0.4444, 0.1389, 0.05556) #> |   |       '-- (0.458,1.34] (0, 0.8889, 0.1111, 0) #> |   '-- (0.458,1.34] (0.1369, 0.75, 0.09524, 0.01786) #> |       '-- (0,0.458] (0.4, 0.55, 0.05, 0) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> |   '-- (2.13,7.54] (0, 0.2, 0.525, 0.275) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214) #>     '-- (0.458,1.34] (0, 0.1429, 0.5714, 0.2857) model_cuts <- cutoff(model) model_2 <- prune(model, model_cuts[2]) draw(model_2) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> |   '-- (0,0.458] (0.809, 0.1809, 0.005025, 0.005025) #> |       '-- (0,0.458] (0.8188, 0.1688, 0.00625, 0.00625) #> |           '-- (0,0.458] (0.8462, 0.1385, 0.007692, 0.007692) #> |               '-- (0.458,1.34] (0.55, 0.4, 0, 0.05) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   '-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> |       '-- (0,0.458] (0.3611, 0.4444, 0.1389, 0.05556) #> |           '-- (0.458,1.34] (0, 0.8889, 0.1111, 0) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214) #>     '-- (0.458,1.34] (0, 0.1429, 0.5714, 0.2857)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Depth of a context tree — depth","title":"Depth of a context tree — depth","text":"function return depth context tree, .e. length longest context represented tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Depth of a context tree — depth","text":"","code":"depth(ct)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Depth of a context tree — depth","text":"ct context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Depth of a context tree — depth","text":"depth tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Depth of a context tree — depth","text":"","code":"dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 3) ## should be 3 depth(dts_ctree) #> [1] 3"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Text based representation of a covlmc model — draw.covlmc","title":"Text based representation of a covlmc model — draw.covlmc","text":"function 'draws' context tree text.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Text based representation of a covlmc model — draw.covlmc","text":"","code":"# S3 method for covlmc draw(   ct,   control = draw_control(),   model = \"coef\",   p_value = TRUE,   digits = 4,   with_state = FALSE,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Text based representation of a covlmc model — draw.covlmc","text":"ct fitted covlmc model. control list low level control parameters text representation. See details draw_control(). model parameter controls display logistic models associated nodes. default model=\"coef\" represents coefficients logistic models associated context. model=\"full\" includes name variables representation (see details). Setting model=NULL removes model representations. Additional parameters can used tweak model representations (see details). p_value specifies whether p-values likelihood ratio tests conducted covlmc construction must included representation. digits numerical parameters p-values represented using base::signif function, using number significant digits specified parameter. with_state specifies whether display state associated dimension logistic model (see details). ... additional arguments draw.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Text based representation of a covlmc model — draw.covlmc","text":"context tree (invisibly).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Text based representation of a covlmc model — draw.covlmc","text":"function uses basic \"ascii art\" represent context tree. Characters used represent structure tree, e.g. branches, can modified using draw_control(). addition structure context tree, draw can represent information attached node (contexts partial contexts). controlled additional parameters depending type context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"tweaking-model-representation","dir":"Reference","previous_headings":"","what":"Tweaking model representation","title":"Text based representation of a covlmc model — draw.covlmc","text":"Model representations affected following additional parameter: time_sep: character(s) used split coefficients list blocks associated time delays covariate inclusion logistic model. first block contains intercept(s), second block covariate values time t-1, third block time t-2, etc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"variable-representation","dir":"Reference","previous_headings":"","what":"Variable representation","title":"Text based representation of a covlmc model — draw.covlmc","text":"model=\"full\", representation includes names variables used logistic models. Names one generated underlying logistic model, e.g. stats::glm(). Numerical variable names used , factors levels appended. intercept denoted () save space. time delays represented underscore followed time delay. instance model uses numerical covariate y two delays, appear variables y_1 y_2.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"state-representation","dir":"Reference","previous_headings":"","what":"State representation","title":"Text based representation of a covlmc model — draw.covlmc","text":"model NULL, coefficients logistic models presented, organized rows associated states. One state used reference state logistic model aims predicting ratio probability another state reference one (log scale). with_state TRUE, display includes row coefficients target state. useful using e.g. VGAM::vglm unused levels target variable automatically dropped model, leading reduce number rows. reference state either shown first row model \"full\" state row model \"coef\".","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Text based representation of a covlmc model — draw.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) draw(m_cov, digits = 3) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] (0.0233 [ -2.81 2.18 -4.45 2.42 ]) #> |   |   '-- (1.34,7.54] (0.0183 [ -19.6 18.4 ]) #> |   '-- (1.34,7.54] (0.676 [ -1.86 ]) #> '-- (1.34,7.54] (0.818 [ 2.54 ]) draw(m_cov, model = NULL) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] (0.02329) #> |   |   '-- (1.34,7.54] (0.01834) #> |   '-- (1.34,7.54] (0.6763) #> '-- (1.34,7.54] (0.8175) draw(m_cov, p_value = FALSE) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] ([ -2.813 2.178 -4.449 2.418 ]) #> |   |   '-- (1.34,7.54] ([ -19.57 18.39 ]) #> |   '-- (1.34,7.54] ([ -1.856 ]) #> '-- (1.34,7.54] ([ 2.535 ]) draw(m_cov, p_value = FALSE, time_sep = \" | \") #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] ([ -2.813 | 2.178 | -4.449 | 2.418 ]) #> |   |   '-- (1.34,7.54] ([ -19.57 | 18.39 ]) #> |   '-- (1.34,7.54] ([ -1.856 ]) #> '-- (1.34,7.54] ([ 2.535 ]) draw(m_cov, model = \"full\", time_sep = \" | \") #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] (0.02329 [ (I)    | day_night_1TRUE | day_night_2TRUE | day_night_3TRUE #> |   |   |                       -2.813 | 2.178           | -4.449          | 2.418           ]) #> |   |   '-- (1.34,7.54] (0.01834 [ (I)    | day_night_1TRUE #> |   |                              -19.57 | 18.39           ]) #> |   '-- (1.34,7.54] (0.6763 [ (I)    #> |                             -1.856 ]) #> '-- (1.34,7.54] (0.8175 [ (I)   #>                           2.535 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Text based representation of a context tree — draw.ctx_tree","title":"Text based representation of a context tree — draw.ctx_tree","text":"function 'draws' context tree text.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Text based representation of a context tree — draw.ctx_tree","text":"","code":"# S3 method for ctx_tree draw(ct, control = draw_control(), frequency = NULL, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Text based representation of a context tree — draw.ctx_tree","text":"ct context tree. control list low level control parameters text representation. See details draw_control(). frequency parameter controls display node level information tree. default NULL value include anything. Setting frequency \"total\" includes frequency (partial) context node, \"detailed\" includes frequency states follow context (contexts.ctx_tree()). ... additional arguments draw.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Text based representation of a context tree — draw.ctx_tree","text":"context tree (invisibly).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Text based representation of a context tree — draw.ctx_tree","text":"function uses basic \"ascii art\" represent context tree. Characters used represent structure tree, e.g. branches, can modified using draw_control(). addition structure context tree, draw can represent information attached node (contexts partial contexts). controlled additional parameters depending type context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.ctx_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Text based representation of a context tree — draw.ctx_tree","text":"","code":"dts_c <- sample(c(\"A\", \"B\", \"CD\"), 100, replace = TRUE) ctree_c <- ctx_tree(dts_c, min_size = 10, max_depth = 2) draw(ctree_c, frequency = \"total\") #> * (100) #> +-- A (28) #> |   '-- B (10) #> '-- B (43) #> |   +-- A (12) #> |   '-- B (21) #> |   '-- CD (10) #> '-- CD (28) #>     '-- B (11) draw(ctree_c, frequency = \"detailed\") #> * (28,44,28) #> +-- A (9,12,7) #> |   '-- B (2,4,4) #> '-- B (10,22,11) #> |   +-- A (3,7,2) #> |   '-- B (6,10,5) #> |   '-- CD (1,5,4) #> '-- CD (9,10,9) #>     '-- B (2,6,3)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":null,"dir":"Reference","previous_headings":"","what":"Text based representation of a context tree — draw","title":"Text based representation of a context tree — draw","text":"function 'draws' context tree text.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Text based representation of a context tree — draw","text":"","code":"draw(ct, control = draw_control(), ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Text based representation of a context tree — draw","text":"ct context tree. control list low level control parameters text representation. See details draw_control(). ... additional arguments draw.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Text based representation of a context tree — draw","text":"context tree (invisibly).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Text based representation of a context tree — draw","text":"function uses basic \"ascii art\" represent context tree. Characters used represent structure tree, e.g. branches, can modified using draw_control(). addition structure context tree, draw can represent information attached node (contexts partial contexts). controlled additional parameters depending type context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Text based representation of a context tree — draw","text":"","code":"dts <- sample(c(0, 1), 100, replace = TRUE) ctree <- ctx_tree(dts, min_size = 10, max_depth = 2) draw(ctree) #> * #> +-- 0 #> |   +-- 0 #> |   '-- 1 #> '-- 1 #>     +-- 0 #>     '-- 1 dts_c <- sample(c(\"A\", \"B\", \"CD\"), 100, replace = TRUE) ctree_c <- ctx_tree(dts_c, min_size = 10, max_depth = 2) draw(ctree_c, draw_control(root = \"x\")) #> x #> +-- A #> |   +-- A #> |   '-- B #> '-- B #> |   +-- A #> |   '-- B #> |   '-- CD #> '-- CD #>     '-- B"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Text based representation of a vlmc — draw.vlmc","title":"Text based representation of a vlmc — draw.vlmc","text":"function 'draws' context tree text.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Text based representation of a vlmc — draw.vlmc","text":"","code":"# S3 method for vlmc draw(ct, control = draw_control(), prob = TRUE, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Text based representation of a vlmc — draw.vlmc","text":"ct fitted vlmc. control list low level control parameters text representation. See details draw_control(). prob parameter controls display node level information tree. default prob=TRUE represents conditional distribution states given (partial) context associated node. Setting prob=FALSE replaces conditional distribution frequency states follow context draw.ctx_tree(). Setting prob=NULL removes additional information. ... additional arguments draw.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Text based representation of a vlmc — draw.vlmc","text":"context tree (invisibly).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Text based representation of a vlmc — draw.vlmc","text":"function uses basic \"ascii art\" represent context tree. Characters used represent structure tree, e.g. branches, can modified using draw_control(). addition structure context tree, draw can represent information attached node (contexts partial contexts). controlled additional parameters depending type context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Text based representation of a vlmc — draw.vlmc","text":"","code":"dts <- sample(c(\"A\", \"B\", \"C\"), 500, replace = TRUE) model <- vlmc(dts, alpha = 0.05) draw(model) #> * (0.342, 0.336, 0.322) draw(model, prob = FALSE) #> * (171, 168, 161) draw(model, prob = NULL) #> *"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Control parameters for draw — draw_control","title":"Control parameters for draw — draw_control","text":"function returns list used fine tune draw() function behaviour.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control parameters for draw — draw_control","text":"","code":"draw_control(   root = \"*\",   first_node = \"+\",   next_node = \"'\",   vbranch = \"|\",   hbranch = \"--\",   open_ct = \"(\",   close_ct = \")\" )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control parameters for draw — draw_control","text":"root character used root node. first_node characters used first child node. next_node characters used children node. vbranch characters used represent branch vertical way. hbranch characters used represent branch horizontal . open_ct characters used start node specific text representation. close_ct characters used end node specific text representation.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control parameters for draw — draw_control","text":"list","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/draw_control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control parameters for draw — draw_control","text":"","code":"draw_control(open_ct = \"[\", close_ct = \"]\") #> $root #> [1] \"*\" #>  #> $first_node #> [1] \"+\" #>  #> $next_node #> [1] \"'\" #>  #> $vbranch #> [1] \"|\" #>  #> $hbranch #> [1] \"--\" #>  #> $open_ct #> [1] \"[\" #>  #> $close_ct #> [1] \"]\" #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/globalearthquake.html","id":null,"dir":"Reference","previous_headings":"","what":"Significant Earthquake Dataset — globalearthquake","title":"Significant Earthquake Dataset — globalearthquake","text":"data set containing Earthquake occured period 1900-2022 GPS coordinates magnitudes.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/globalearthquake.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Significant Earthquake Dataset — globalearthquake","text":"","code":"globalearthquake"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/globalearthquake.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Significant Earthquake Dataset — globalearthquake","text":"data frame 98785 rows 12 variables: date_time Date time POSIXct format latitude latitude earthquake, -90° 90° longitude longitude earthquake, -180° 180° mag magnitude earthquake, indicating strenth Date date seisme occured nbweeks number weeks since 1900/01/01 year year month month year month_day day month week week number week_day day week 1 = Sunday 7 = Saturday year_day day year 1 366","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/globalearthquake.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Significant Earthquake Dataset — globalearthquake","text":"Earthquake Catalog, U.S. Geological Survey, Department Interior. https://www.usgs.gov/programs/earthquake-hazards","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/globalearthquake.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Significant Earthquake Dataset — globalearthquake","text":"compiled version full data set available U.S. Geological Survey Earthquake Events (USGS) public domain. data set contains earthquake 1900 2022 magnitude higher 5.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a covlmc model — is_covlmc","title":"Test if the object is a covlmc model — is_covlmc","text":"function returns TRUE VLMC models covariates FALSE objects.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a covlmc model — is_covlmc","text":"","code":"is_covlmc(x)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a covlmc model — is_covlmc","text":"x R object.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a covlmc model — is_covlmc","text":"TRUE VLMC models covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a covlmc model — is_covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) # should be true is_ctx_tree(m_cov) #> [1] TRUE # should be true is_covlmc(m_cov) #> [1] TRUE # should be false is_vlmc(m_cov) #> [1] FALSE"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_ctx_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a context tree — is_ctx_tree","title":"Test if the object is a context tree — is_ctx_tree","text":"function returns TRUE context trees FALSE objects.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_ctx_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a context tree — is_ctx_tree","text":"","code":"is_ctx_tree(x)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_ctx_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a context tree — is_ctx_tree","text":"x R object.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_ctx_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a context tree — is_ctx_tree","text":"TRUE context trees.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_ctx_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a context tree — is_ctx_tree","text":"","code":"dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 2) is_ctx_tree(dts_ctree) #> [1] TRUE is_ctx_tree(dts) #> [1] FALSE"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if the object is a vlmc model — is_vlmc","title":"Test if the object is a vlmc model — is_vlmc","text":"function returns TRUE VLMC models FALSE objects.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if the object is a vlmc model — is_vlmc","text":"","code":"is_vlmc(x)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if the object is a vlmc model — is_vlmc","text":"x R object.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if the object is a vlmc model — is_vlmc","text":"TRUE VLMC models.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/is_vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if the object is a vlmc model — is_vlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))) model <- vlmc(dts) # should be true is_ctx_tree(model) #> [1] TRUE # should be true is_vlmc(model) #> [1] TRUE # should be false is_covlmc(model) #> [1] FALSE"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","title":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","text":"function evaluates log-likelihood VLMC covariates fitted discrete time series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","text":"","code":"# S3 method for covlmc logLik(object, initial = c(\"truncated\", \"specific\", \"extended\"), ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","text":"object covlmc representation. initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See loglikelihood() details. ... additional parameters logLik.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","text":"object class logLik. number, log-likelihood (CO)VLMC following attributes: df: number parameters used VLMC likelihood calculation nobs: number observations included likelihood calculation initial: value initial parameter used compute likelihood","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-Likelihood of a VLMC with covariates — logLik.covlmc","text":"","code":"## Likelihood for a fitted VLMC with covariates. pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) ll <- logLik(m_cov) attributes(ll) #> $df #> [1] 5 #>  #> $nobs #> [1] 1005 #>  #> $initial #> [1] \"truncated\" #>  #> $class #> [1] \"logLik\" #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-Likelihood of a VLMC — logLik.vlmc","title":"Log-Likelihood of a VLMC — logLik.vlmc","text":"function evaluates log-likelihood VLMC fitted discrete time series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-Likelihood of a VLMC — logLik.vlmc","text":"","code":"# S3 method for vlmc logLik(object, initial = c(\"truncated\", \"specific\", \"extended\"), ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-Likelihood of a VLMC — logLik.vlmc","text":"object vlmc representation. initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See loglikelihood() details. ... additional parameters logLik.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-Likelihood of a VLMC — logLik.vlmc","text":"object class logLik. number, log-likelihood (CO)VLMC following attributes: df: number parameters used VLMC likelihood calculation nobs: number observations included likelihood calculation initial: value initial parameter used compute likelihood","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/logLik.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-Likelihood of a VLMC — logLik.vlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) m_nocovariate <- vlmc(dts) ll <- logLik(m_nocovariate) ll #> 'log Lik.' -207.9581 (df=69) attributes(ll) #> $nobs #> [1] 945 #>  #> $df #> [1] 69 #>  #> $initial #> [1] \"truncated\" #>  #> $class #> [1] \"logLik\" #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"function evaluates log-likelihood VLMC covariates fitted discrete time series. optional arguments newdata provided, function evaluates instead log-likelihood (new) discrete time series new covariates must provided newcov parameter.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"","code":"# S3 method for covlmc loglikelihood(   vlmc,   initial = c(\"truncated\", \"specific\", \"extended\"),   newdata,   newcov,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"vlmc covlmc representation. initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See details. newdata optional discrete time series. newcov optional data frame new values covariates. ... additional parameters loglikelihood.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"object class logLikMixVLMC logLik. number, log-likelihood (CO)VLMC following attributes: df: number parameters used VLMC likelihood calculation nobs: number observations included likelihood calculation initial: value initial parameter used compute likelihood","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"definition likelihood function depends value initial parameters, see section well dedicated vignette: vignette(\"likelihood\", package = \"mixvlmc\"). VLMC covariates support \"truncated\" \"specific\" likelihood functions.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"likelihood-calculation","dir":"Reference","previous_headings":"","what":"likelihood calculation","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"(CO)VLMC depth()=k, need k past values order compute context given observation. consequence, time series x, contexts x[1] x[k] unknown. Depending value initial different likelihood functions used tackle difficulty: initial==\"truncated\" (default): likelihood computed using x[(k+1):length(x)] initial==\"specific\": likelihood computed full time series using specific context initial values, x[1] x[k]. specific context unique, leading perfect likelihood 1 (0 log scale). Thus numerical value likelihood identical one obtained initial==\"truncated\" computed length(x) model parameters previous case. initial==\"relaxed\": likelihood computed full time series using relaxed context matching initial values, x[1] x[k]. can seen compromised two possibilities: relaxed context matching needs general turn internal nodes context tree actual context, increasing number parameters, much \"specific\". However, likelihood say x[1] empty context generally 1 thus full likelihood smaller one computed \"specific\". \"relaxed\" likelihood supported covlmc() models. See dedicated vignette mathematically oriented discussion: vignette(\"likelihood\", package = \"mixvlmc\").","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-Likelihood of a VLMC with covariates — loglikelihood.covlmc","text":"","code":"## Likelihood for a fitted VLMC with covariates. pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) ll <- loglikelihood(m_cov) ll #> 'log Lik.' -224.1199 (df= 5, nb obs.= 1005, initial=\"truncated\") attr(ll, \"nobs\") #> [1] 1005  ## Likelihood for new time series and covariates with previously ## fitted VLMC with covariates pc_new <- powerconsumption[powerconsumption$week == 11, ] dts_new <- cut(pc_new$active_power, breaks = breaks, labels = labels) dts_cov_new <- data.frame(day_night = (pc_new$hour >= 7 & pc_new$hour <= 17)) ll_new <- loglikelihood(m_cov, newdata = dts_new, newcov = dts_cov_new) ll_new #> 'log Lik.' -249.0136 (df= 5, nb obs.= 1007, initial=\"truncated\") attributes(ll_new) #> $df #> [1] 5 #>  #> $nobs #> [1] 1007 #>  #> $initial #> [1] \"truncated\" #>  #> $class #> [1] \"logLikMixVLMC\" \"logLik\"        #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-Likelihood of a VLMC — loglikelihood","title":"Log-Likelihood of a VLMC — loglikelihood","text":"function evaluates log-likelihood VLMC fitted discrete time series. optional argument newdata provided, function evaluates instead log-likelihood (new) discrete time series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-Likelihood of a VLMC — loglikelihood","text":"","code":"loglikelihood(   vlmc,   initial = c(\"truncated\", \"specific\", \"extended\"),   newdata,   ... )  # S3 method for vlmc loglikelihood(   vlmc,   initial = c(\"truncated\", \"specific\", \"extended\"),   newdata,   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-Likelihood of a VLMC — loglikelihood","text":"vlmc vlmc representation. initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See details. newdata optional discrete time series. ... additional parameters loglikelihood.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-Likelihood of a VLMC — loglikelihood","text":"object class logLikMixVLMC logLik. number, log-likelihood (CO)VLMC following attributes: df: number parameters used VLMC likelihood calculation nobs: number observations included likelihood calculation initial: value initial parameter used compute likelihood","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log-Likelihood of a VLMC — loglikelihood","text":"definition likelihood function depends value initial parameters, see section well dedicated vignette: vignette(\"likelihood\", package = \"mixvlmc\"). VLMC objects, method loglikelihood.vlmc used. VLMC covariables, loglikelihood.covlmc instead called. informations loglikelihood methods, use methods(loglikelihood) associated documentation.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"likelihood-calculation","dir":"Reference","previous_headings":"","what":"likelihood calculation","title":"Log-Likelihood of a VLMC — loglikelihood","text":"(CO)VLMC depth()=k, need k past values order compute context given observation. consequence, time series x, contexts x[1] x[k] unknown. Depending value initial different likelihood functions used tackle difficulty: initial==\"truncated\" (default): likelihood computed using x[(k+1):length(x)] initial==\"specific\": likelihood computed full time series using specific context initial values, x[1] x[k]. specific context unique, leading perfect likelihood 1 (0 log scale). Thus numerical value likelihood identical one obtained initial==\"truncated\" computed length(x) model parameters previous case. initial==\"relaxed\": likelihood computed full time series using relaxed context matching initial values, x[1] x[k]. can seen compromised two possibilities: relaxed context matching needs general turn internal nodes context tree actual context, increasing number parameters, much \"specific\". However, likelihood say x[1] empty context generally 1 thus full likelihood smaller one computed \"specific\". \"relaxed\" likelihood supported covlmc() models. See dedicated vignette mathematically oriented discussion: vignette(\"likelihood\", package = \"mixvlmc\").","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/loglikelihood.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-Likelihood of a VLMC — loglikelihood","text":"","code":"## Likelihood for a fitted VLMC. pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) m_nocovariate <- vlmc(dts) ll <- loglikelihood(m_nocovariate) ll #> 'log Lik.' -207.9581 (df= 69, nb obs.= 945, initial=\"truncated\") attr(ll, \"nobs\") #> [1] 945 attr(ll, \"df\") #> [1] 69  ## Likelihood for a new time series with previously fitted VLMC. pc_new <- powerconsumption[powerconsumption$week == 11, ] dts_new <- cut(pc_new$active_power, breaks = breaks, labels = labels) ll_new <- loglikelihood(m_nocovariate, newdata = dts_new) ll_new #> 'log Lik.' -240.5671 (df= 69, nb obs.= 945, initial=\"truncated\") attributes(ll_new) #> $nobs #> [1] 945 #>  #> $df #> [1] 69 #>  #> $initial #> [1] \"truncated\" #>  #> $class #> [1] \"logLikMixVLMC\" \"logLik\"        #>  ll_new_specific <- loglikelihood(m_nocovariate, initial = \"specific\", newdata = dts_new) ll_new_specific #> 'log Lik.' -240.5671 (df= 132, nb obs.= 1008, initial=\"specific\") attributes(ll_new_specific) #> $nobs #> [1] 1008 #>  #> $df #> [1] 132 #>  #> $initial #> [1] \"specific\" #>  #> $class #> [1] \"logLikMixVLMC\" \"logLik\"        #>  ll_new_extended <- loglikelihood(m_nocovariate, initial = \"extended\", newdata = dts_new) ll_new_extended #> 'log Lik.' -254.0705 (df= 71, nb obs.= 1008, initial=\"extended\") attributes(ll_new_extended) #> $nobs #> [1] 1008 #>  #> $df #> [1] 71 #>  #> $initial #> [1] \"extended\" #>  #> $class #> [1] \"logLikMixVLMC\" \"logLik\"        #>"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"function computes returns predictive quality metrics VLMC VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"","code":"# S3 method for covlmc metrics(model, ...)  # S3 method for metrics.covlmc print(x, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"model context based model compute predictive metrics. ... Additional parameters predictive metrics computation. x metrics.covlmc object, results call metrics.covlmc()","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"object class metrics.covlmc following components: accuracy: accuracy predictions conf_mat: confusion matrix predictions, predicted values rows true values columns auc: AUC predictive model object print method recalls basic information model together values components .","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"context based model computes transition probabilities contexts. Using maximum transition probability decision rule, can used \"predict\" new state likely follow current one, given context. quality predictions evaluated using standard metrics including: accuracy full confusion matrix area roc curve (AUC), considering context based model (conditional) probability estimator. use Hand Till (2001) multiclass AUC case state space 2 states","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"print(metrics.covlmc): Prints predictive metrics VLMC model covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"David J. Hand Robert J. Till (2001). \"Simple Generalisation Area ROC Curve Multiple Class Classification Problems.\" Machine Learning 45(2), p. 171--186. DOI: doi:10.1023/:1010920819831 .","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive quality metrics for VLMC with covariates — metrics.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) metrics(m_cov) #> VLMC with covariate context tree on 0, 1  #>  cutoff in quantile scale: 0.05 #>  Number of contexts: 4  #>  Maximum context length: 3  #>  Confusion matrix:  #>     0   1    #>   0 318 31   #>   1 32  624  #>  Accurary: 0.9373  #>  AUC: 0.9443"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive quality metrics for context based models — metrics","title":"Predictive quality metrics for context based models — metrics","text":"function computes returns predictive quality metrics VLMC VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive quality metrics for context based models — metrics","text":"","code":"metrics(model, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive quality metrics for context based models — metrics","text":"model context based model compute predictive metrics. ... Additional parameters predictive metrics computation.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive quality metrics for context based models — metrics","text":"returned value guaranteed least three components accuracy: accuracy predictions conf_mat: confusion matrix predictions, predicted values rows true values columns auc: AUC predictive model","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictive quality metrics for context based models — metrics","text":"context based model computes transition probabilities contexts. Using maximum transition probability decision rule, can used \"predict\" new state likely follow current one, given context. quality predictions evaluated using standard metrics including: accuracy full confusion matrix area roc curve (AUC), considering context based model (conditional) probability estimator. use Hand Till (2001) multiclass AUC case state space 2 states","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predictive quality metrics for context based models — metrics","text":"David J. Hand Robert J. Till (2001). \"Simple Generalisation Area ROC Curve Multiple Class Classification Problems.\" Machine Learning 45(2), p. 171--186. DOI: doi:10.1023/:1010920819831 .","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive quality metrics for context based models — metrics","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) model <- vlmc(dts) metrics(model) #> VLMC context tree on 0, 1  #>  cutoff: 1.921 (quantile: 0.05) #>  Number of contexts: 69  #>  Maximum context length: 63  #>  Confusion matrix:  #>     0   1    #>   0 317 29   #>   1 33  627  #>  Accurary: 0.9384  #>  AUC: 0.9656"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive quality metrics for VLMC — metrics.vlmc","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"function computes returns predictive quality metrics VLMC VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"","code":"# S3 method for vlmc metrics(model, ...)  # S3 method for metrics.vlmc print(x, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"model context based model compute predictive metrics. ... Additional parameters predictive metrics computation. x metrics.vlmc object, results call metrics.vlmc()","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"object class metrics.vlmc following components: accuracy: accuracy predictions conf_mat: confusion matrix predictions, predicted values rows true values columns auc: AUC predictive model object print method recalls basic information model together values components .","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"context based model computes transition probabilities contexts. Using maximum transition probability decision rule, can used \"predict\" new state likely follow current one, given context. quality predictions evaluated using standard metrics including: accuracy full confusion matrix area roc curve (AUC), considering context based model (conditional) probability estimator. use Hand Till (2001) multiclass AUC case state space 2 states","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"print(metrics.vlmc): Prints predictive metrics VLMC model.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"David J. Hand Robert J. Till (2001). \"Simple Generalisation Area ROC Curve Multiple Class Classification Problems.\" Machine Learning 45(2), p. 171--186. DOI: doi:10.1023/:1010920819831 .","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/metrics.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive quality metrics for VLMC — metrics.vlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] breaks <- c(   0,   median(powerconsumption$active_power, na.rm = TRUE),   max(powerconsumption$active_power, na.rm = TRUE) ) labels <- c(0, 1) dts <- cut(pc$active_power, breaks = breaks, labels = labels) model <- vlmc(dts) metrics(model) #> VLMC context tree on 0, 1  #>  cutoff: 1.921 (quantile: 0.05) #>  Number of contexts: 69  #>  Maximum context length: 63  #>  Confusion matrix:  #>     0   1    #>   0 317 29   #>   1 33  627  #>  Accurary: 0.9384  #>  AUC: 0.9656"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/mixvlmc-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mixvlmc: Variable Length Markov Chains with Covariates — mixvlmc-package","title":"mixvlmc: Variable Length Markov Chains with Covariates — mixvlmc-package","text":"Estimates Variable Length Markov Chains (VLMC) models VLMC covariates models discrete sequences. Supports model selection via information criteria simulation new sequences estimated model. See Bühlmann, P. Wyner, . J. (1999) doi:10.1214/aos/1018031204  VLMC Zanin Zambom, ., Kim, S. Lopes Garcia, N. (2022) doi:10.1111/jtsa.12615  VLMC covariates.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/mixvlmc-package.html","id":"package-options","dir":"Reference","previous_headings":"","what":"Package options","title":"mixvlmc: Variable Length Markov Chains with Covariates — mixvlmc-package","text":"Mixvlmc uses following options(): mixvlmc.maxit: maximum number iterations model fitting covlmc() mixvlmc.predictive: specifies computing engine used model fitting covlmc(). Two values supported: \"glm\" (default value): covlmc() uses stats::glm() binomial link (stats::binomial()) two values state space, VGAM::vglm() multinomial link (VGAM::multinomial()) state space three values; \"multinom\": covlmc() uses nnet::multinom() cases. first option \"glm\" recommended stats::glm() VGAM::vglm() able detect deal degeneracy data set.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/mixvlmc-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mixvlmc: Variable Length Markov Chains with Covariates — mixvlmc-package","text":"Maintainer: Fabrice Rossi Fabrice.Rossi@apiacoa.org (ORCID) [copyright holder] contributors: Hugo Le Picard lepicardhugo@gmail.com (ORCID) [contributor] Guénolé Joubioux guenole.joubioux@gmail.com [contributor]","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"function plots results tune_vlmc() tune_covlmc().","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"","code":"# S3 method for tune_vlmc plot(   x,   value = c(\"criterion\", \"likelihood\"),   cutoff = c(\"quantile\", \"native\"),   ... )  # S3 method for tune_covlmc plot(   x,   value = c(\"criterion\", \"likelihood\"),   cutoff = c(\"quantile\", \"native\"),   ... )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"x tune_vlmc object value criterion plot (default \"criterion\"). cutoff scale used cut criterion (default \"quantile\") ... additional parameters passed base::plot()","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"tune_vlmc object invisibly","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"standard plot consists showing evolution criterion used select model (AIC() BIC()) function cut criterion expressed quantile scale (quantile used default offer common default behaviour vlmc() covlmc()). Parameters can used display instead loglikelihood() model (setting value=\"likelihood\") use native scale cut available (setting cutoff=\"native\").","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"customisation","dir":"Reference","previous_headings":"","what":"Customisation","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"function sets several default calling base::plot(), namely: type: \"l\" default use line representation; xlab: \"Cut (quantile scale)\" default, adapted actual scale; ylab: name criterion \"Log likelihood\". parameters can overridden specifying values calling function. parameters specified addition x, value cutoff passed base::plot().","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/plot.tune_vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the results of automatic (CO)VLMC complexity selection — plot.tune_vlmc","text":"","code":"dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) tune_result <- tune_vlmc(dts) ## default plot plot(tune_result)  ## likelihood plot(tune_result, value = \"likelihood\")  ## parameters overriding plot(tune_result,   value = \"likelihood\",   xlab = \"Cut off\", type = \"b\" )  pc <- powerconsumption[powerconsumption$week %in% 10:12, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) dts_best_model_tune <- tune_covlmc(dts, dts_cov, criterion = \"AIC\") plot(dts_best_model_tune)  plot(dts_best_model_tune, value = \"likelihood\")"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/powerconsumption.html","id":null,"dir":"Reference","previous_headings":"","what":"Individual household electric power consumption — powerconsumption","title":"Individual household electric power consumption — powerconsumption","text":"data set containing measurements electric power consumption one household time resolution 10 minutes full year 2008.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/powerconsumption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Individual household electric power consumption — powerconsumption","text":"","code":"powerconsumption"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/powerconsumption.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Individual household electric power consumption — powerconsumption","text":"data frame 52704 rows 15 variables: month month 2008 month_day day month hour hour (0 23) minute starting minute 10 minutes period row active_power global average active power 10 minute period (kilowatt) reactive_power global average reactive power 10 minute period (kilowatt) voltage Average voltage 10 minute period (volt) intensity global average current intensity  10 minute period (ampere) sub_metering_1 energy sub-metering . 1 (watt-hour active energy averaged 10 minute period). corresponds kitchen, containing mainly dishwasher, oven microwave (hot plates electric gas powered) sub_metering_2 energy sub-metering . 2 (watt-hour active energy averaged 10 minute period). corresponds laundry room, containing washing-machine, tumble-drier, refrigerator light. sub_metering_3 energy sub-metering . 3 (watt-hour active energy averaged 10 minute period). corresponds electric water-heater air-conditioner. week week number week_day day week 1 = Sunday 7 = Saturday year_day day year 1 366 (2008 leap year) date_time Date time POSIXct format","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/powerconsumption.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Individual household electric power consumption — powerconsumption","text":"Individual household electric power consumption, 2012, G. Hebrail . Berard, UC Irvine Machine Learning repository. doi:10.24432/C58K54","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/powerconsumption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Individual household electric power consumption — powerconsumption","text":"simplified version full data available UCI Machine Learning Repository Creative Commons Attribution 4.0 International (CC 4.0) license, provided Georges Hebrail Alice Berard. original data averaged 10 minute time period (discarding missing data period). data set contains measurements year 2008. Notice different variables expressed adapted units. particular, sub-meters measuring active energy (watt-hour) global active power expressed kilowatt.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"function prunes vlmc covariates. model must estimated keep_data=TRUE enable pruning.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"","code":"# S3 method for covlmc prune(vlmc, alpha = 0.05, cutoff = NULL, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"vlmc fitted VLMC model covariates. alpha number (0,1) (default: 0.05) cutoff value quantile scale pruning. cutoff supported vlmc covariates. ... additional arguments prune function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"pruned covlmc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"Post pruning VLMC covariates straightforward procedure applied vlmc() (see cutoff.vlmc() prune.vlmc()). efficiency reasons, covlmc() estimates logistic models considered useful given set construction parameters. aggressive pruning threshold, contexts become leaves context tree new logistic models must estimated. Thus pruning opportunities given cutoff.covlmc() subset interesting cut offs given covlmc. Nevertheless, covlmc share vlmc() principle post pruning covlmc give model buidling directly covlmc, provided post pruning alpha smaller alpha used build initial model.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prune a Variable Length Markov Chain with covariates — prune.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5, keep_data = TRUE) draw(m_cov) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] #> |   |   +-- (0,1.34] (0.02329 [ -2.813 2.178 -4.449 2.418 ]) #> |   |   '-- (1.34,7.54] (0.01834 [ -19.57 18.39 ]) #> |   '-- (1.34,7.54] (0.6763 [ -1.856 ]) #> '-- (1.34,7.54] (0.8175 [ 2.535 ]) m_cov_cuts <- cutoff(m_cov) p_cov <- prune(m_cov, m_cov_cuts[1]) draw(p_cov) #> * #> +-- (0,1.34] #> |   +-- (0,1.34] (0.02001 [ -2.759 2.785 -2.525 ]) #> |   '-- (1.34,7.54] (0.6763 [ -1.856 ]) #> '-- (1.34,7.54] (0.8175 [ 2.535 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":null,"dir":"Reference","previous_headings":"","what":"Prune a Variable Length Markov Chain (VLMC) — prune","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"function prunes VLMC.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"","code":"prune(vlmc, alpha = 0.05, cutoff = NULL, ...)  # S3 method for vlmc prune(vlmc, alpha = 0.05, cutoff = NULL, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"vlmc fitted VLMC model. alpha number (0,1] (default: 0.05) cut value quantile scale pruning. cutoff positive number: cut value native (log likelihood ratio) scale pruning. Defaults value obtained alpha. Takes precedence alpha specified. ... additional arguments prune function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"pruned VLMC","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"general, pruning VLMC efficient constructing two VLMC (base one pruned one). numerical instabilities, building VLMC cut pruning b cut (>b) produce VLMC building directly VLMC b cut . Interesting cut values can extracted VLMC using cutoff() function. automated model selection provided tune_vlmc(), direct use cutoff reserved advanced exploration set trees can obtained complex one, e.g. implement model selection techniques provided tune_vlmc().","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/prune.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prune a Variable Length Markov Chain (VLMC) — prune","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))) base_model <- vlmc(dts, alpha = 0.1) model_cuts <- cutoff(base_model) pruned_model <- prune(base_model, model_cuts[3]) draw(pruned_model) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> |   '-- (0,0.458] (0.809, 0.1809, 0.005025, 0.005025) #> |       '-- (0,0.458] (0.8188, 0.1688, 0.00625, 0.00625) #> |           '-- (0,0.458] (0.8462, 0.1385, 0.007692, 0.007692) #> |               '-- (0.458,1.34] (0.55, 0.4, 0, 0.05) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   '-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> |       '-- (0,0.458] (0.3611, 0.4444, 0.1389, 0.05556) #> |           '-- (0.458,1.34] (0, 0.8889, 0.1111, 0) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214) direct_simple <- vlmc(dts, alpha = model_cuts[3]) draw(direct_simple) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> |   '-- (0,0.458] (0.809, 0.1809, 0.005025, 0.005025) #> |       '-- (0,0.458] (0.8188, 0.1688, 0.00625, 0.00625) #> |           '-- (0,0.458] (0.8462, 0.1385, 0.007692, 0.007692) #> |               '-- (0.458,1.34] (0.55, 0.4, 0, 0.05) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   '-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> |       '-- (0,0.458] (0.3611, 0.4444, 0.1389, 0.05556) #> |           '-- (0.458,1.34] (0, 0.8889, 0.1111, 0) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214) # pruned_model and direct_simple should be identical all.equal(pruned_model, direct_simple) #> [1] TRUE"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a discrete time series for a covlmc — simulate.covlmc","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"function simulates time series distribution estimated given covlmc object.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"","code":"# S3 method for covlmc simulate(object, nsim = 1, seed = NULL, covariate, init = NULL, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"object fitted covlmc object. nsim length simulated time series (defaults 1). seed optional random seed. covariate values covariates init optional initial sequence time series ... additional arguments.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"simulated discrete time series type one used build covlmc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"VLMC covariates model needs covariates compute transition probabilities. covariates must submitted data frame using covariate argument. addition,  time series can initiated fixed sequence specified via init parameter.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a discrete time series for a covlmc — simulate.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 5) # new week with day light from 6:00 to 18:00 new_cov <- data.frame(day_night = rep(c(rep(FALSE, 59), rep(TRUE, 121), rep(FALSE, 60)), times = 7)) new_dts <- simulate(m_cov, nrow(new_cov), seed = 0, covariate = new_cov) new_dts_2 <- simulate(m_cov, nrow(new_cov), seed = 0, covariate = new_cov, init = dts[1:10])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a discrete time series for a vlmc — simulate.vlmc","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"function simulates time series distribution estimated given vlmc object.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"","code":"# S3 method for vlmc simulate(object, nsim = 1, seed = NULL, init = NULL, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"object fitted vlmc object. nsim length simulated time series (defaults 1). seed optional random seed. init optional initial sequence time series ... additional arguments.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"simulated discrete time series type one used build vlmc.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"time series can initiated fixed sequence specified via init parameter.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/simulate.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a discrete time series for a vlmc — simulate.vlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))) model <- vlmc(dts, min_size = 5) new_dts <- simulate(model, 500, seed = 0) new_dts_2 <- simulate(model, 500, seed = 0, init = dts[1:5])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/states.html","id":null,"dir":"Reference","previous_headings":"","what":"State space of a context tree — states","title":"State space of a context tree — states","text":"function returns state space context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/states.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"State space of a context tree — states","text":"","code":"states(ct)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/states.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"State space of a context tree — states","text":"ct context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/states.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"State space of a context tree — states","text":"state space context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/states.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"State space of a context tree — states","text":"","code":"dts <- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0) dts_ctree <- ctx_tree(dts, min_size = 1, max_depth = 2) ## should be c(0, 1) states(dts_ctree) #> [1] 0 1"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim a COVLMC — trim.covlmc","title":"Trim a COVLMC — trim.covlmc","text":"function returns trimmed COVLMC cached data removed.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim a COVLMC — trim.covlmc","text":"","code":"# S3 method for covlmc trim(ct, keep_model = FALSE, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim a COVLMC — trim.covlmc","text":"ct context tree. keep_model specifies whether keep internal models () ... additional arguments trim function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim a COVLMC — trim.covlmc","text":"trimmed context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trim a COVLMC — trim.covlmc","text":"Called keep_model set FALSE (default case), trimming maximal reduces usability model. particular loglikelihood.covlmc() used new data, contexts.covlmc() support model extraction, simulate.covlmc(), metrics.covlmc()  prune.covlmc() used . Called keep_model set TRUE, trimming process less complete. particular internal models simplified using butcher::butcher() additional minor reductions. saves less memory enables use loglikelihood.covlmc() new data well use simulate.covlmc().","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trim a COVLMC — trim.covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week %in% 5:7, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) m_cov <- covlmc(dts, dts_cov, min_size = 10, keep_data = TRUE) print(object.size(m_cov), units = \"Mb\") #> 11 Mb t_m_cov_model <- trim(m_cov, keep_model = TRUE) print(object.size(t_m_cov_model), units = \"Mb\") #> 2.5 Mb t_m_cov <- trim(m_cov) print(object.size(t_m_cov), units = \"Mb\") #> 0 Mb"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim a context tree — trim","title":"Trim a context tree — trim","text":"function returns trimmed context tree match positions removed.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim a context tree — trim","text":"","code":"trim(ct, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim a context tree — trim","text":"ct context tree. ... additional arguments trim function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim a context tree — trim","text":"trimmed context tree.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trim a context tree — trim","text":"","code":"## context tree trimming dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 1000, replace = TRUE) dts_tree <- ctx_tree(dts, max_depth = 10, min_size = 5, keep_position = TRUE) print(object.size(dts_tree)) #> 156128 bytes dts_tree <- trim(dts_tree) print(object.size(dts_tree)) #> 106312 bytes"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","title":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","text":"function returns trimmed context tree match positions removed.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","text":"","code":"# S3 method for vlmc trim(ct, ...)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","text":"ct VLMC. ... additional arguments trim function.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","text":"trimmed VLMC","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/trim.vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This function returns a trimmed VLMC from which match positions have been\nremoved. — trim.vlmc","text":"","code":"## VLMC trimming is generally useless unless match positions were kept pc <- powerconsumption[powerconsumption$week %in% 5:6, ] dts <- cut(pc$active_power, breaks = 4) model <- vlmc(dts, keep_match = TRUE) print(object.size(model)) #> 56648 bytes model <- trim(model) ## memory use should be reduced print(object.size(model)) #> 14984 bytes nm_model <- vlmc(dts) print(object.size(nm_model)) #> 14984 bytes nm_model <- trim(nm_model) ## no effect when match positions are not kept print(object.size(nm_model)) #> 14984 bytes"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"function fits Variable Length Markov Chain Covariates (coVLMC) discrete time series coupled time series covariates optimizing information criterion (BIC AIC).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"","code":"tune_covlmc(   x,   covariate,   criterion = c(\"BIC\", \"AIC\"),   initial = c(\"truncated\", \"specific\", \"extended\"),   min_size = 5,   max_depth = 100,   verbose = 0,   save = c(\"best\", \"initial\", \"all\"),   trimming = c(\"full\", \"partial\", \"none\") )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"x discrete time series; can numeric, character, factor logical. covariate data frame covariates. criterion criterion used select best model. Either \"BIC\" (default) \"AIC\" (see details). initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See loglikelihood() details. min_size integer >= 1 (default: 2). Minimum number observations context growing phase initial context tree. max_depth integer >= 1 (default: 100). Longest context considered growing phase initial context tree (see details). verbose integer >= 0 (default: 0). Verbosity level pruning process. save specify BIC models saved pruning process. default value \"best\" asks function keep best model according criterion. save=\"initial\" function keeps addition initial (complex) model pruned selection process. save=\"\", function returns models considered selection process. See details memory occupation. trimming specify type trimming used saving intermediate models, see details.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"list following components: best_model: optimal VLMC criterion: criterion used select optimal VLMC initial: likelihood function used select optimal VLMC results: data frame details pruning process saved_models: list intermediate coVLMCs save=\"initial\" save=\"\". contains initial component large coVLMC obtained first component list coVLMC obtained pruning initial one.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"function automates process fitting large coVLMC discrete time series covlmc() pruning tree (cutoff() prune()) get optimal respect information criterion. avoid missing long term dependencies, function uses max_depth parameter initial guess relies automatic increase value make sure initial context tree limited min_size parameter. initial value alpha parameter covlmc() also set conservative value avoid prior simplification context tree. initial coVLMC obtained, cutoff() prune() functions used build coVLMC models generated using smaller values alpha parameter. best model selected collection, including initial complex tree, one minimizes chosen information criterion.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"memory-occupation","dir":"Reference","previous_headings":"","what":"Memory occupation","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"covlmc objects tend large saving models search optimal model can lead unreasonable use memory. avoid problem, models kept trimmed form using trim.covlmc() keep_model=FALSE. initial model best one saved untrimmed. default behaviour corresponds trimming=\"full\". Setting trimming=\"partial\" asks function use keep_model=TRUE trim.covlmc() intermediate models. Finally, trimming=\"none\" turns trimming, discouraged expected small data sets.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_covlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an optimal Variable Length Markov Chain with Covariates (coVLMC) — tune_covlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week %in% 5:7, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1)))) dts_cov <- data.frame(day_night = (pc$hour >= 7 & pc$hour <= 17)) dts_best_model_tune <- tune_covlmc(dts, dts_cov) draw(as_covlmc(dts_best_model_tune)) #> * #> +-- (0,1.28] (0.0001741 [ -2.789 0.7354 ]) #> '-- (1.28,7.54] (0.31 [ 2.488 ])"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"function fits Variable Length Markov Chain (VLMC) discrete time series optimizing information criterion (BIC AIC).","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"","code":"tune_vlmc(   x,   criterion = c(\"BIC\", \"AIC\"),   initial = c(\"truncated\", \"specific\", \"extended\"),   min_size = 2,   max_depth = 100,   verbose = 0,   save = c(\"best\", \"initial\", \"all\") )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"x discrete time series; can numeric, character, factor logical. criterion criterion used select best model. Either \"BIC\" (default) \"AIC\" (see details). initial specifies likelihood function, precisely way first observations contexts calculated integrated likelihood. See loglikelihood() details. min_size integer >= 1 (default: 2). Minimum number observations context growing phase initial context tree. max_depth integer >= 1 (default: 100). Longest context considered growing phase initial context tree (see details). verbose integer >= 0 (default: 0). Verbosity level pruning process. save specify BIC models saved pruning process. default value \"best\" asks function keep best model according criterion. save=\"initial\" function keeps addition initial (complex) model pruned selection process. save=\"\", function returns models considered selection process.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"list following components: best_model: optimal VLMC criterion: criterion used select optimal VLMC initial: likelihood function used select optimal VLMC results: data frame details pruning process saved_models: list intermediate VLMCs save=\"initial\" save=\"\". contains initial component large VLMC obtained first component list VLMC obtained pruning initial one.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"function automates process fitting large VLMC discrete time series vlmc() pruning tree (cutoff() prune()) get optimal respect information criterion. avoid missing long term dependencies, function uses max_depth parameter initial guess relies automatic increase value make sure initial context tree limited min_size parameter. initial value cutoff parameter vlmc() also set conservative values (depending criterion) avoid prior simplification context tree. initial VLMC obtained, cutoff() prune() functions used build VLMC models generated using larger values initial cut parameter. best model selected collection, including initial complex tree, one minimizes chosen information criterion.","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/tune_vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an optimal Variable Length Markov Chain (VLMC) — tune_vlmc","text":"","code":"dts <- sample(as.factor(c(\"A\", \"B\", \"C\")), 100, replace = TRUE) tune_result <- tune_vlmc(dts) draw(tune_result$best_model) #> * (0.21, 0.43, 0.36)"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Variable Length Markov Chain (VLMC) — vlmc","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"function fits  Variable Length Markov Chain (VLMC) discrete time series.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"","code":"vlmc(   x,   alpha = 0.05,   cutoff = NULL,   min_size = 2L,   max_depth = 100L,   prune = TRUE,   keep_match = FALSE )"},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"x discrete time series; can numeric, character, factor logical. alpha number (0,1] (default: 0.05) cut value quantile scale pruning phase. cutoff non negative number: cut value native (likelihood ratio) scale pruning phase. Defaults value obtained alpha. Takes precedence alpha specified. min_size integer >= 1 (default: 2). Minimum number observations context growing phase context tree. max_depth integer >= 1 (default: 100). Longest context considered growing phase context tree. prune logical: specify whether context tree pruned (default behaviour). keep_match logical: specify whether keep context matches (default FALSE)","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"fitted vlmc model.","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"VLMC built using Bühlmann Wyner's algorithm consists fitting context tree (see ctx_tree()) time series pruning way conditional distribution next state time series given context significantly different distribution given truncated version context. construction context tree controlled min_size max_depth, exactly ctx_tree(). Significativity measured using likelihood ratio test (threshold can specified terms ratio cutoff) quantile scale alpha. Pruning can postponed setting prune=FALSE. Using combination cutoff() prune(), complexity VLMC can adjusted. VLMC model can pruned construction, prune=FALSE convenience parameter avoid setting alpha=1 (essentially prevents pruning). Automated model selection provided tune_vlmc().","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"Bühlmann, P. Wyner, . J. (1999), \"Variable length Markov chains. Ann. Statist.\" 27 (2) 480-513 doi:10.1214/aos/1018031204","code":""},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/reference/vlmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Variable Length Markov Chain (VLMC) — vlmc","text":"","code":"pc <- powerconsumption[powerconsumption$week == 5, ] dts <- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))) model <- vlmc(dts) draw(model) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> |   '-- (0,0.458] (0.809, 0.1809, 0.005025, 0.005025) #> |       '-- (0,0.458] (0.8188, 0.1688, 0.00625, 0.00625) #> |           '-- (0,0.458] (0.8462, 0.1385, 0.007692, 0.007692) #> |               '-- (0.458,1.34] (0.55, 0.4, 0, 0.05) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   +-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> |   |   '-- (0,0.458] (0.3611, 0.4444, 0.1389, 0.05556) #> |   |       '-- (0.458,1.34] (0, 0.8889, 0.1111, 0) #> |   '-- (0.458,1.34] (0.1369, 0.75, 0.09524, 0.01786) #> |       '-- (0,0.458] (0.4, 0.55, 0.05, 0) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> |   '-- (2.13,7.54] (0, 0.2, 0.525, 0.275) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214) #>     '-- (0.458,1.34] (0, 0.1429, 0.5714, 0.2857) depth(model) #> [1] 5 ## reduce the detph of the model shallow_model <- vlmc(dts, max_depth = 3) draw(shallow_model, prob = FALSE) #> * (252, 252, 252, 252) #> +-- (0,0.458] (200, 48, 2, 1) #> '-- (0.458,1.34] (50, 168, 27, 7) #> |   +-- (0,0.458] (18, 20, 7, 3) #> |   '-- (0.458,1.34] (23, 126, 16, 3) #> |       '-- (0,0.458] (8, 11, 1, 0) #> '-- (1.34,2.13] (1, 31, 183, 37) #> |   '-- (2.13,7.54] (0, 8, 21, 11) #> '-- (2.13,7.54] (1, 4, 40, 207) #>     '-- (0.458,1.34] (0, 1, 4, 2) ## improve probability estimates robust_model <- vlmc(dts, min_size = 25) draw(robust_model, prob = FALSE) ## show the frequencies #> * (252, 252, 252, 252) #> +-- (0,0.458] (200, 48, 2, 1) #> '-- (0.458,1.34] (50, 168, 27, 7) #> |   '-- (0,0.458] (18, 20, 7, 3) #> '-- (1.34,2.13] (1, 31, 183, 37) #> |   '-- (2.13,7.54] (0, 8, 21, 11) #> '-- (2.13,7.54] (1, 4, 40, 207) draw(robust_model) #> * (0.25, 0.25, 0.25, 0.25) #> +-- (0,0.458] (0.7968, 0.1912, 0.007968, 0.003984) #> '-- (0.458,1.34] (0.1984, 0.6667, 0.1071, 0.02778) #> |   '-- (0,0.458] (0.375, 0.4167, 0.1458, 0.0625) #> '-- (1.34,2.13] (0.003968, 0.123, 0.7262, 0.1468) #> |   '-- (2.13,7.54] (0, 0.2, 0.525, 0.275) #> '-- (2.13,7.54] (0.003968, 0.01587, 0.1587, 0.8214)"},{"path":[]},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"","what":"New features","title":"mixvlmc (development version)","text":"contexts can now report positions context original time series log likelihood calculations performed logLik loglikelihood revised, expanded include three possible definitions likelihood function, documented new vignette tune_vlmc tune_covlmc can used different likelihood function definitions results tune_vlmc tune_covlmc can plotted using base R graphics cutoff uses new tolerance parameter avoid reporting cut values almost identical due numerical imprecision","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/news/index.html","id":"minor-improvements-and-bug-fixes-development-version","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"mixvlmc (development version)","text":"Fixed several bugs related degenerate VLMC (issue #55) Fixed bug likelihood calculation internal context nodes Improved type consistency reporting counts integers contexts results Fixed documentation: models can adjusted time series logical values Synchronized ctx_tree documentation default value Synchronized contexts documentation default value Added trimming COVLMC models trim.covlmc","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/news/index.html","id":"mixvlmc-011","dir":"Changelog","previous_headings":"","what":"mixvlmc 0.1.1","title":"mixvlmc 0.1.1","text":"CRAN release: 2023-07-10 Added missing documentation return values simulate.vlmc simulate.covlmc","code":""},{"path":"https://fabrice-rossi.github.io/mixvlmc/dev/news/index.html","id":"mixvlmc-010","dir":"Changelog","previous_headings":"","what":"mixvlmc 0.1.0","title":"mixvlmc 0.1.0","text":"Added NEWS.md file track changes package.","code":""}]
